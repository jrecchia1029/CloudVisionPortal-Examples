- service: arista.studio.v1.StudioConfigService
  method: Set
  body:
    value:
      key:
        studio_id: studio-evpn-services
        workspace_id: &workspace_id ws-evpn-services
      display_name: EVPN Services
      description: Define and configure EVPN services for an L3 network fabric, including configuration of VRFs, VLANs, VNIs and associated IP addressing
      template:
        type: TEMPLATE_TYPE_MAKO
        body: |
          <%
          import ipaddress
          import json
          import os
          import re
          import time
          from itertools import count, groupby
          import tagsearch_python.tagsearch_pb2_grpc as tsgr
          import tagsearch_python.tagsearch_pb2 as tspb
          import arista.tag.v2
          from arista.tag.v2.tag_pb2 import Tag, \
              TagKey, \
              TagAssignment, \
              TagAssignmentKey, \
              TagAssignmentConfig

          veos_regex = r'(v|c)EOS(-)*(Lab)*'


          fabric_variables = {
              "bgp_peer_groups": {
                  "EVPN_OVERLAY_CORE": {
                      "name": "EVPN-OVERLAY-CORE",
                      "password": None,
                      'evpn_ebgp_gateway_multihop': 15
                  }
              }
          }


          def alphanum_key(key):
              return [convert(c) for c in re.split('([0-9]+)', str(key))]


          def convert(text):
              return int(text) if text.isdigit() else text.lower()


          def natural_sort(iterable, sort_key=None):
              if iterable is None:
                  return []

              def alphanum_key(key):
                  if sort_key is not None and isinstance(key, dict):
                      return [convert(c) for c in re.split("([0-9]+)", str(key.get(sort_key, key)))]
                  else:
                      return [convert(c) for c in re.split("([0-9]+)", str(key))]

              return sorted(iterable, key=alphanum_key)


          def string_to_list(string_to_convert):
              numbers = []
              segments = [segment.strip() for segment in string_to_convert.split(",")]
              for segment in segments:
                  if "-" in segment:
                      for i in range(int(segment.split("-")[0]), int(segment.split("-")[1]) + 1):
                          numbers.append(i)
                  else:
                      numbers.append(int(segment))
              return numbers


          def list_compress(list_to_compress):
              if not isinstance(list_to_compress, list):
                  raise TypeError('value must be of type list, got %s' % type(list_to_compress))
              G = (list(x) for y, x in groupby(sorted(list_to_compress), lambda x, c=count(): next(c) - x))
              return (",".join("-".join(map(str, (g[0], g[-1])[:len(g)])) for g in G))


          def validIPAddress(ip):
              '''
              Returns True for a valid ipv4 address
              Returns False for a valid ipv6 address
              Return None for a nonvalid ip address
              '''
              try:
                  return True if type(ipaddress.ip_address(ip)) is ipaddress.IPv4Address else False
              except ValueError:
                  return None


          def convert_dicts(dictionary, primary_key="name", secondary_key=None):
              """
              The `arista.avd.convert_dicts` filter will convert a dictionary containing nested dictionaries to a list of
              dictionaries. It inserts the outer dictionary keys into each list item using the primary_key `name` (key name is
              configurable) and if there is a non-dictionary value,it inserts this value to
              secondary key (key name is configurable), if secondary key is provided.
              This filter is intended for:
              - Seemless data model migration from dictionaries to lists.
              - Improve Ansible's processing performance when dealing with large dictionaries by converting them to lists of dictionaries.
              Note: If there is a non-dictionary value with no secondary key provided, it will pass through untouched
              To use this filter:
              ```jinja
              {# convert list of dictionary with default `name:` as the primary key and None secondary key #}
              {% set example_list = example_dictionary | arista.avd.convert_dicts %}
              {% for example_item in example_list %}
              item primary key is {{ example_item.name }}
              {% endfor %}
              {# convert list of dictionary with `id:` set as the primary key and `types:` set as the secondary key #}
              {% set example_list = example_dictionary | arista.avd.convert_dicts('id','types') %}
              {% for example_item in example_list %}
              item primary key is {{ example_item.id }}
              item secondary key is {{ example_item.types }}
              {% endfor %}
              ```
              Parameters
              ----------
              dictionary : any
                  Nested Dictionary to convert - returned untouched if not a nested dictionary and list
              primary_key : str, optional
                  Name of primary key used when inserting outer dictionary keys into items.
              secondary_key : str, optional
                  Name of secondary key used when inserting dictionary values which are list into items.
              Returns
              -------
              any
                  Returns list of dictionaries or input variable untouched if not a nested dictionary/list.
              """
              if not isinstance(dictionary, (dict, list)) or os.environ.get("AVD_DISABLE_CONVERT_DICTS"):
                  # Not a dictionary/list, return the original
                  return dictionary
              elif isinstance(dictionary, list):
                  output = []
                  for element in dictionary:
                      if not isinstance(element, dict):
                          item = {}
                          item.update({primary_key: element})
                          output.append(item)
                      elif primary_key not in element and secondary_key is not None:
                          # if element of nested dictionary is a dictionary but primary key is missing, insert primary and secondary keys.
                          for key in element:
                              output.append(
                                  {
                                      primary_key: key,
                                      secondary_key: element[key],
                                  }
                              )
                      else:
                          output.append(element)
                  return output
              else:
                  output = []
                  for key in dictionary:
                      if secondary_key is not None:
                          # Add secondary key for the values if secondary key is provided
                          item = {}
                          item.update({primary_key: key})
                          item.update({secondary_key: dictionary[key]})
                          output.append(item)
                      else:
                          if not isinstance(dictionary[key], dict):
                              # Not a nested dictionary
                              output.append({primary_key: key})
                          else:
                              # Nested dictionary
                              item = dictionary[key].copy()
                              item.update({primary_key: key})
                              output.append(item)
                  return output


          def get(dictionary, key, default=None, required=False, org_key=None, separator="."):
              """
              Get a value from a dictionary or nested dictionaries.
              Key supports dot-notation like "foo.bar" to do deeper lookups.
              Returns the supplied default value or None if the key is not found and required is False.
              Parameters
              ----------
              dictionary : dict
                  Dictionary to get key from
              key : str
                  Dictionary Key - supporting dot-notation for nested dictionaries
              default : any
                  Default value returned if the key is not found
              required : bool
                  Fail if the key is not found
              org_key : str
                  Internal variable used for raising exception with the full key name even when called recursively
              separator: str
                  String to use as the separator parameter in the split function. Useful in cases when the key
                  can contain variables with "." inside (e.g. hostnames)
              Returns
              -------
              any
                  Value or default value
              Raises
              ------
              AristaAvdMissingVariableError
                  If the key is not found and required == True
              """

              if org_key is None:
                  org_key = key
              keys = str(key).split(separator)
              value = dictionary.get(keys[0])
              if value is None:
                  if required is True:
                      raise TypeError(org_key)
                  return default
              else:
                  if len(keys) > 1:
                      return get(value, separator.join(keys[1:]), default=default, required=required, org_key=org_key, separator=separator)
                  else:
                      return value


          def default(*values):
              """
              Accepts any number of arguments. Return the first value which is not None
              Last resort is to return None.
              Parameters
              ----------
              *values : any
                  One or more values to test
              Returns
              -------
              any
                  First value which is not None
              """

              for value in values:
                  if value is not None:
                      return value
              return None


          def get_ip(pool: str, prefixlen: int, subnet_offset: int, ip_offset: int) -> str:
              pool_network = ipaddress.ip_network(pool, strict=False)
              prefixlen_diff = prefixlen - pool_network.prefixlen
              subnet_size = (int(pool_network.hostmask) + 1) >> prefixlen_diff
              if (subnet_offset + 1) * subnet_size > pool_network.num_addresses:
                  raise Exception(f"Unable to get {subnet_offset + 1} /{prefixlen} subnets from pool {pool}")
              subnet = ipaddress.ip_network((int(pool_network.network_address) + subnet_offset * subnet_size, prefixlen))
              try:
                  ip = subnet[ip_offset]
              except IndexError as e:
                  raise Exception(f"Unable to get {ip_offset+1} hosts in subnet {subnet} taken from pool {pool}") from e
              return str(ip)


          def check_vni_overlap(tenants):
              '''
              Summary:
                  Asserts errors if vlans or vnis use overlapping vni numbers
              Returns
                  None
              '''
              for tenant in convert_dicts(tenants):
                  vnis_seen = {}
                  for vrf in convert_dicts(tenant["vrfs"]):
                      if vrf.get("vni") is not None:
                          assert vnis_seen.get(vrf['vni']) is None, f"VNI {vrf['vni']} found in multiple places -> " \
                                                                    f"{vnis_seen[vrf['vni']]['name']} " \
                                                                    f"and {vrf['name']} in tenant {tenant['name']}. " \
                                                                    f"Please correct the VNI " \
                                                                    f"conflict before moving forward."
                          vnis_seen[vrf['vni']] = vrf
                      for svi in convert_dicts(vrf["svis"], primary_key='id'):
                          if svi.get("vni") is not None:
                              assert vnis_seen.get(svi['vni']) is None, f"VNI {svi['vni']} found in multiple places -> " \
                                                                        f"{vnis_seen[svi['vni']].get('name')} and " \
                                                                        f"{svi['id']} in tenant {tenant['name']}. " \
                                                                        f"Please correct the VNI " \
                                                                        f"conflict before moving forward."
                              vnis_seen[svi['vni']] = svi

                  for l2vlan in convert_dicts(tenant["l2vlans"], primary_key='id'):
                      if l2vlan.get("vni") is not None:
                          assert vnis_seen.get(l2vlan['vni']) is None, f"VNI {l2vlan['vni']} found in multiple places -> " \
                                                                       f"{vnis_seen[l2vlan['vni']].get('name')} and " \
                                                                       f"{l2vlan['id']} in tenant {tenant['name']}. " \
                                                                       f"Please correct the VNI " \
                                                                       f"conflict before moving forward."
                          vnis_seen[l2vlan['vni']] = l2vlan


          def get_mlag_ip(switch_facts, mlag_peer_ipv4_pool, mlag_subnet_mask, mlag_role):
              mlag_subnet = ipaddress.ip_network(mlag_peer_ipv4_pool)
              assert mlag_subnet.prefixlen <= mlag_subnet_mask, "MLAG Subnet mask length must be longer than " \
                                                                "the mask of the mlag subnet"
              if mlag_subnet.prefixlen != mlag_subnet_mask:
                  mlag_subnet = list(mlag_subnet.subnets(new_prefix=mlag_subnet_mask))[int(switch_facts['mlag_primary_id']) - 1]
              if mlag_role == "primary":
                  return list(mlag_subnet.hosts())[0]
              elif mlag_role == "secondary":
                  return list(mlag_subnet.hosts())[1]
              return


          def set_base_config(config, switch_facts):
              # Set router-bgp
              if switch_facts['network_services_l3']:
                  config['ip_routing'] = True
                  config['router_bgp']['as'] = switch_facts['bgp_as']
                  config['router_bgp']['router_id'] = switch_facts['router_id']
              return config


          def set_overlay_config(config, switch_facts):
              overlay_data = {}
              # Set evpn route servers
              overlay_data['evpn_gateway_remote_peers'] = {}
              if switch_facts.get('evpn_gateway_remote_peers'):
                  for evpn_gw_remote_peer in switch_facts['evpn_gateway_remote_peers']:
                      server = {}
                      server['bgp_as'] = evpn_gw_remote_peer.get('peerBgpAsn')
                      server['ip_address'] = evpn_gw_remote_peer.get('peerIpAddress')
                      overlay_data['evpn_gateway_remote_peers'].update({ evpn_gw_remote_peer['peerHostname']: server })
              # Set EVPN_OVERLAY_CORE peer group config
              if switch_facts.get('evpn_gateway_vxlan_l2') or switch_facts.get('evpn_gateway_vxlan_l3'):
                  config['router_bgp']['peer_groups'][fabric_variables['bgp_peer_groups']['EVPN_OVERLAY_CORE']['name']] = {
                      "type": "evpn",
                      "update_source": "Loopback0",
                      "bfd": True,
                      "ebgp_multihop": fabric_variables['bgp_peer_groups']['EVPN_OVERLAY_CORE']['evpn_ebgp_gateway_multihop'],
                      "send_community": "all",
                      "maximum_routes": 0
                  }
                  if fabric_variables['bgp_peer_groups']['EVPN_OVERLAY_CORE'].get('password'):
                      config['router_bgp']['peer_groups'][fabric_variables['bgp_peer_groups']['EVPN_OVERLAY_CORE']['name']]['password'] = \
                          fabric_variables['bgp_peer_groups']['EVPN_OVERLAY_CORE']['password']
              # Set EVPN_OVERLAY_CORE neighbors config
              if switch_facts.get('evpn_gateway_vxlan_l2') or switch_facts.get('evpn_gateway_vxlan_l3'):
                  for evpn_gw_remote_peer in natural_sort(overlay_data['evpn_gateway_remote_peers'].keys()):
                      config['router_bgp']['neighbors'][overlay_data['evpn_gateway_remote_peers'][evpn_gw_remote_peer]['ip_address']] = {
                          "peer_group": fabric_variables['bgp_peer_groups']['EVPN_OVERLAY_CORE']['name'],
                          "description": evpn_gw_remote_peer,
                          "remote_as": overlay_data['evpn_gateway_remote_peers'][evpn_gw_remote_peer]['bgp_as']
                      }
              # Disable ipv4 address family for EVPN_OVERLAY_CORE peer group
              if switch_facts.get('evpn_gateway_vxlan_l2') or switch_facts.get('evpn_gateway_vxlan_l3'):
                  config['router_bgp']['address_family_ipv4'] = {
                      "peer_groups": {
                          fabric_variables['bgp_peer_groups']['EVPN_OVERLAY_CORE']['name']: {
                              "activate": False
                          }
                      }
                  }
              # Enable evpn address family for EVPN_OVERLAY_CORE peer group
              if switch_facts.get('evpn_gateway_vxlan_l2') or switch_facts.get('evpn_gateway_vxlan_l3'):
                  config['router_bgp']['address_family_evpn'] = {
                      "peer_groups": {
                          fabric_variables['bgp_peer_groups']['EVPN_OVERLAY_CORE']['name']: {
                              "domain_remote": True,
                              "activate": True
                          }
                      }
                  }
                  if switch_facts.get('evpn_gateway_vxlan_l3'):
                      config['router_bgp']['address_family_evpn']['neighbor_default'] = {
                          "next_hop_self_received_evpn_routes": {
                              "enable": True,
                              "inter_domain": switch_facts.get('evpn_gateway_vxlan_l3_inter_domain')
                          }
                      }
              return config


          def set_network_services_config(config, switch_facts):
              # logic (Probably will be easier to break away from AVD logic)
              if switch_facts["network_services_l2"] is True or switch_facts["network_services_l3"] is True:
                  network_services_data = {}
                  tmp_tenants = []
                  # tenants
                  for tenant in convert_dicts(switch_facts["all_tenants"]):
                      if tenant["name"] in switch_facts.get('tenants', []):
                          switch_tenant = switch_facts["all_tenants"][tenant["name"]]
                          # vrfs
                          tmp_vrfs = []
                          for vrf in convert_dicts(tenant["vrfs"]):
                              if vrf["name"] in switch_facts["tenants"][tenant["name"]].get("vrfs", {}):
                                  switch_vrf = switch_tenant["vrfs"][vrf["name"]]
                                  # svis & bgp_peers
                                  tmp_svis = []
                                  for svi in convert_dicts(vrf["svis"], primary_key='id'):
                                      if svi["id"] in switch_facts["tenants"][tenant["name"]]["vrfs"][vrf["name"]].get("svis", []):
                                          tmp_svis.append(svi)

                                  # evpn multicast
                                  vrf["_evpn_l3_multicast_enabled"] = default(get(vrf, "evpn_l3_multicast.enabled"), get(tenant, "evpn_l3_multicast.enabled"))
                                  # Enable switch_facts multicast settings if evpn multicast is enabled
                                  if vrf["_evpn_l3_multicast_enabled"]:
                                      switch_facts["evpn_multicast"] = True
                                      switch_facts["igmp_snooping_enabled"] = True
                                  rps = []
                                  for rp_address in default(get(vrf, "pim_rp_addresses"), get(tenant, "pim_rp_addresses"), []):
                                      if switch_facts["serial_number"] in get(rp_address, "nodes", default=[switch_facts["serial_number"]]):
                                          for rp_ip in get(
                                              rp_address,
                                              "rps",
                                              required=True,
                                              org_key=f"pim_rp_addresses.rps under VRF '{vrf['name']}' in Tenant '{tenant['name']}'",
                                          ):
                                              if rp_groups := get(rp_address, "groups"):
                                                  rps.append({"address": rp_ip, "groups": rp_groups})
                                              else:
                                                  rps.append({"address": rp_ip})
                                  if rps:
                                      vrf["_pim_rp_addresses"] = rps

                                  for evpn_peg in default(get(vrf, "evpn_l3_multicast.evpn_peg"), get(tenant, "evpn_l3_multicast.evpn_peg"), []):
                                      if switch_facts["serial_number"] in evpn_peg.get("nodes", [switch_facts["serial_number"]]) and rps:
                                          vrf["_evpn_l3_multicast_evpn_peg_transit"] = evpn_peg.get("transit")
                                          break

                                  vrf.update({'svis': tmp_svis, 'bgp_peers': vrf.get("bgp_peers", {})})
                                  tmp_vrfs.append(vrf)

                          # l2vlans
                          tmp_l2vlans = []
                          for l2vlan in convert_dicts(tenant["l2vlans"], primary_key='id'):
                              if l2vlan["id"] in switch_facts["tenants"][tenant["name"]].get("l2vlans", []):
                                  # Enable switch_facts multicast settings if evpn multicast is enabled
                                  vlan_evpn_l2_multicast_enabled = default(get(l2vlan, "evpn_l2_multicast.enabled"), get(tenant, "evpn_l2_multicast.enabled"))
                                  if vlan_evpn_l2_multicast_enabled is True:
                                      switch_facts["evpn_multicast"] = True
                                      switch_facts["igmp_snooping_enabled"] = True
                                  tmp_l2vlans.append(l2vlan)

                          # vlan aware bundles
                          tmp_vlan_aware_bundles = []
                          for vlan_aware_bundle in convert_dicts(tenant["vlan_aware_bundles"]):
                              if vlan_aware_bundle["name"] in switch_facts["tenants"][tenant["name"]].get("vlan_aware_bundles", []):
                                  tmp_vlan_aware_bundles.append(vlan_aware_bundle)

                          tenant.update({'vrfs': tmp_vrfs, 'l2vlans': tmp_l2vlans, 'vlan_aware_bundles': tmp_vlan_aware_bundles})
                          tmp_tenants.append(tenant)

                  network_services_data["tenants"] = tmp_tenants

              # Log network services data
              # ctx.info(f"Filtered Network Services Data: {network_services_data}")
              # Configure vlans
              if switch_facts['network_services_l2']:
                  # Enable dhcp smart relay
                  config['ip_dhcp_relay'] = {"information_option": True}
                  # Section commented out for now until more detail is found on which platforms
                  # support dhcp snooping
                  # Enable dhcp snooping
                  # config['ip_dhcp_snooping'] = {
                  #     "information_option": True,
                  #     "vlans": []
                  # }
                  ip_igmp_snooping = {}
                  igmp_snooping_vlans = []
                  igmp_snooping_enabled = get(switch_facts, "igmp_snooping_enabled", required=False)
                  tenant_igmp_snooping_querier = tenant.get("igmp_snooping_querier", {})

                  for tenant in network_services_data["tenants"]:
                      # Set l3 vlan config
                      for vrf in tenant.get('vrfs', []):
                          # Create vlans
                          for svi in vrf.get('svis', []):
                              # Create L3 vlans
                              config['vlans'][svi['id']] = {
                                  "tenant": tenant['name'],
                                  "name": svi['name']
                              }
                              # Create L3 SVI with helper address pointing towards CVP
                              config['vlan_interfaces'][f"Vlan{svi['id']}"] = {}
                              # Section commented out for now until more detail is found on which platforms
                              # support dhcp snooping
                              # if vrf == "default":
                              #     config['vlan_interfaces'][f"Vlan{svi}"]['ip_helpers'] = {
                              #         "127.0.0.1": {}
                              #     }
                              #     # enable snooping on that vlan
                              #     config['ip_dhcp_snooping']['vlans'].append(svi)

                          # Set vrf ibgp peering vlan params
                          if switch_facts.get('mlag') and switch_facts['network_services_l3'] \
                                  and vrf.get('enable_mlag_ibgp_peering_vrfs'):
                              ibgp_vlan = vrf['mlag_ibgp_peering_vlan']
                              config['vlans'][ibgp_vlan] = {
                                  "tenant": tenant['name'],
                                  "name": f"MLAG_iBGP_{vrf['name']}",
                                  "trunk_groups": ['MLAG_VRF_PEER']
                              }

                      # Set l2 vlan config
                      for l2vlan in tenant.get('l2vlans', []):
                          config['vlans'][l2vlan['id']] = {
                              "tenant": tenant['name'],
                              "name": l2vlan['name']
                          }
                          if l2vlan.get('etree_role') and l2vlan['etree_role'] == "leaf" and switch_facts.get('vtep'):
                              config['vlans'][vlan]['etree'] = {'role': 'leaf'}
                          # Section commented out for now until more detail is found on which platforms
                          # support dhcp snooping
                          # Create L2 SVI with helper address pointing towards CVP
                          # config['vlan_interfaces'][f"Vlan{l2vlan['id]}"]['ip_helpers'] = {
                          #     "127.0.0.1": {}
                          # }
                          # # enable snooping on the vlan
                          # config['ip_dhcp_snooping']['vlans'].append(l2vlan['id'])

                          # igmp snooping
                          ip_igmp_snooping_vlan = {}
                          if igmp_snooping_enabled is not None:
                              ip_igmp_snooping_vlan["enabled"] = igmp_snooping_enabled
                          igmp_snooping_querier = l2vlan.get("igmp_snooping_querier", {})
                          vlan_evpn_l2_multicast_enabled = default(get(l2vlan, "evpn_l2_multicast.enabled"), get(tenant, "evpn_l2_multicast.enabled"))
                          if switch_facts.get("vtep") and vlan_evpn_l2_multicast_enabled:
                              igmp_snooping_querier_enabled = True
                              ip_igmp_snooping_vlan["id"] = l2vlan["id"]
                              ip_igmp_snooping_vlan["querier"] = {"enabled": igmp_snooping_querier_enabled}
                              address = default(igmp_snooping_querier.get("source_address"), tenant_igmp_snooping_querier.get("source_address"), switch_facts["router_id"])
                              if address is not None:
                                  ip_igmp_snooping_vlan["querier"]["address"] = address

                              version = default(
                                  igmp_snooping_querier.get("version"),
                                  tenant_igmp_snooping_querier.get("version"),
                              )
                              if version is not None:
                                  ip_igmp_snooping_vlan["querier"]["version"] = version

                              igmp_snooping_vlans.append(ip_igmp_snooping_vlan)

                      if igmp_snooping_enabled and igmp_snooping_vlans:
                          config["ip_igmp_snooping"] = {
                              "globally_enabled": True,
                              "vlans": igmp_snooping_vlans
                          }

              if switch_facts['network_services_l3']:
                  for tenant in network_services_data["tenants"]:
                      for vrf in tenant.get('vrfs', []):
                          # configure vrfs
                          config['vrfs'][vrf['name']] = {
                              "tenant": tenant['name'],
                              "ip_routing": True
                          }
                          # multicast
                          if get(vrf, "_evpn_l3_multicast_enabled"):
                              config["router_multicast"]["vrfs"].append({
                                  "name": vrf['name'],
                                  "ipv4": {
                                      "routing": True
                                  }
                              })

                              # pim rps
                              vrf_rps = get(vrf, "_pim_rp_addresses")
                              if vrf_rps:
                                  config["router_pim_sparse_mode"]["vrfs"].append(
                                      {
                                          "name": vrf["name"],
                                          "ipv4": {
                                              "rp_addresses": vrf_rps,
                                          }
                                      }
                                  )

                          # configure static routes
                          if vrf.get('static_routes') is not None:
                              for static_route in vrf['static_routes']:
                                  sr = {
                                      "destination_address_prefix": static_route['destination_address_prefix'],
                                      "vrf": vrf['name']
                                  }
                                  if static_route.get('gateway') and static_route['gateway'].strip() != "":
                                      sr['gateway'] = static_route['gateway']
                                  if static_route.get('distance'):
                                      sr['distance'] = str(static_route['distance'])
                                  if static_route.get('tag'):
                                      sr['tag'] = str(static_route['tag'])
                                  if static_route.get('name') and static_route['name'].strip() != "":
                                      sr['name'] = static_route['name']
                                  if static_route.get('metric'):
                                      sr['metric'] = str(static_route['metric'])
                                  if static_route.get('interface') and static_route['interface'].strip() != "":
                                      sr['interface'] = static_route['interface']
                                  config['static_routes'].append(sr)

                          for svi in vrf.get("svis", []):
                              if "ip_virtual_router_addresses" not in svi or "ip_address" not in svi:
                                  # Skip svi if VARP is not set or if there is no unique ip_address
                                  continue

                              for virtual_router_address in svi["ip_virtual_router_addresses"]:
                                  if "/" not in virtual_router_address:
                                      # Only create static routes for VARP entries with masks
                                      continue

                                  config['static_routes'].append(
                                      {
                                          "destination_address_prefix": str(ipaddress.ip_network(virtual_router_address, strict=False)),
                                          "vrf": vrf["name"],
                                          "name": "VARP",
                                          "interface": f"Vlan{svi['id']}",
                                      }
                                  )

                          # configure ethernet interfaces
                          if vrf.get('l3_interfaces') is not None:
                              l3_interface_subif_parents = []
                              for l3_iface in vrf['l3_interfaces']:
                                  eth_iface = {}
                                  l3_interface_subif_id = None
                                  if "." in l3_iface['interfaces'][0]:
                                      if l3_iface.get('encapsulation_dot1q_vlan'):
                                          l3_interface_subif_id = l3_iface['encapsulation_dot1q_vlan']
                                      else:
                                          l3_interface_subif_id = l3_iface['interfaces'][0].split('.')[1]
                                      l3_interface_subif_parents.append(l3_iface['interfaces'][0].split('.')[0])
                                  if l3_interface_subif_id is not None:
                                      eth_iface['type'] = "l3dot1q"
                                      eth_iface['encapsulation_dot1q_vlan'] = l3_interface_subif_id
                                  else:
                                      eth_iface['type'] = "routed"
                                  eth_iface['peer_type'] = "l3_interface"
                                  eth_iface['vrf'] = vrf['name']
                                  eth_iface['ip_address'] = l3_iface['ip_addresses'][0]
                                  if l3_iface.get('mtu'):
                                      eth_iface['mtu'] = l3_iface['mtu']
                                  if l3_iface.get('enabled') is not None:
                                      eth_iface['shutdown'] = not l3_iface["enabled"]
                                  if l3_iface.get('description') and l3_iface['description'].strip() != "":
                                      eth_iface['description'] = l3_iface['description']
                                  if l3_iface.get('raw_eos_cli'):
                                      eth_iface['eos_cli'] = l3_iface['raw_eos_cli']
                                  config['ethernet_interfaces'][l3_iface['interfaces'][0]] = eth_iface
                              for parent_iface in l3_interface_subif_parents:
                                  config['ethernet_interfaces'][parent_iface] = {
                                      "type": "routed",
                                      "peer_type": "l3_interface",
                                      "shutdown": False
                                  }

                          # configure route maps
                          if vrf.get('bgp_peers'):
                              for peer, peer_info in vrf['bgp_peers'].items():
                                  if peer_info.get('set_ipv4_next_hop') or peer_info.get('set_ipv6_next_hop'):
                                      config['route_maps'][f"RM-{vrf['name']}-{peer}-SET-NEXT-HOP-OUT"] = {
                                          "sequence_numbers": {
                                              10: {
                                                  "type": "permit",
                                                  "set": []
                                              }
                                          }
                                      }
                                      if peer_info.get('set_ipv4_next_hop'):
                                          (config['route_maps'][f"RM-{vrf['name']}-{peer}-SET-NEXT-HOP-OUT"]
                                          ['sequence_numbers'][10]['set']).append(f"ip next-hop {peer_info['set_ipv4_next_hop']}")
                                      elif peer_info.get('set_ipv6_next_hop'):
                                          (config['route_maps'][f"RM-{vrf['name']}-{peer}-SET-NEXT-HOP-OUT"]
                                          ['sequence_numbers'][10]['set']).append(f"ipv6 next-hop {peer_info['set_ipv6_next_hop']}")

                  # if mlag is enabled
                  if switch_facts.get('mlag'):
                      # Get mlag_peer_switch facts
                      mlag_peer_switch_facts = get_switch_basics_from_tags(switch_facts['mlag_peer_serial_number'])
                      mlag_peer_switch_facts = get_neighbors(mlag_peer_switch_facts)
                      mlag_peer_switch_facts = set_switch_facts(mlag_peer_switch_facts)
                      # Initialize mlag port-channel interface for ibgp trunk groups
                      config['port_channel_interfaces'][f"Port-Channel{switch_facts['mlag_port_channel_id']}"] = {"trunk_groups": []}

                  # configure interfaces
                  for tenant in network_services_data['tenants']:
                      for vrf in tenant.get('vrfs', []):
                          # set and configure vtep diagnostic loopback interfaces
                          if vrf.get('vtep_diagnostic'):
                              loopback_id = vrf['vtep_diagnostic']['loopback']
                              loopback_description = f"{vrf['name']}_VTEP_DIAGNOSTICS"
                              loopback_ipv4_pool = vrf['vtep_diagnostic']['loopback_ip_range']
                              loopback_ip_host_addresses = list(ipaddress.ip_network(loopback_ipv4_pool).hosts())
                              loopback_ip = str(loopback_ip_host_addresses[int(switch_facts['id']) - 1])
                              config['loopback_interfaces'][f"Loopback{loopback_id}"] = {
                                  "description": loopback_description,
                                  "shutdown": False,
                                  "vrf": vrf['name'],
                                  "ip_address": f"{loopback_ip}/32"
                              }
                              # Set virtual-source-nat-vrfs
                              config['virtual_source_nat_vrfs'][vrf['name']] = {
                                  "ip_address": loopback_ip
                              }

                          if switch_facts['network_services_l2'] and switch_facts['network_services_l3']:
                              # configure svis
                              for svi in vrf.get('svis', []):
                                  config['vlan_interfaces'][f"Vlan{svi['id']}"]['tenant'] = tenant['name']
                                  config['vlan_interfaces'][f"Vlan{svi['id']}"]['vrf'] = vrf['name']

                                  # Configure VIP and IP
                                  if svi.get('ip_address_virtual'):
                                      config['vlan_interfaces'][f"Vlan{svi['id']}"]['ip_address_virtual'] \
                                          = svi['ip_address_virtual']
                                  if svi.get('ip_virtual_router_addresses'):
                                      config['vlan_interfaces'][f"Vlan{svi['id']}"]['ip_virtual_router_addresses'] \
                                          = svi['ip_virtual_router_addresses']
                                  if svi.get('ip_address'):
                                      config['vlan_interfaces'][f"Vlan{svi['id']}"]['ip_address'] \
                                          = svi['ip_address']

                                  if svi.get('ip_helpers'):
                                      config['vlan_interfaces'][f"Vlan{svi['id']}"]['ip_helpers'] = {}
                                      for helper_address, dhcp_info in svi['ip_helpers'].items():
                                          config['vlan_interfaces'][f"Vlan{svi['id']}"]['ip_helpers'][helper_address] = {
                                              "source_interface": dhcp_info.get('source_interface')
                                          }
                                  # if mtu
                                  if svi.get('mtu'):
                                      config['vlan_interfaces'][f"Vlan{svi['id']}"]['mtu'] = svi['mtu']
                                  # if arp aging timeout
                                  if svi.get('arp'):
                                      if svi['arp'].get('aging_timeout'):
                                          config['vlan_interfaces'][f"Vlan{svi['id']}"]['arp_aging_timeout'] = svi['arp']['aging_timeout']

                                  # multicast
                                  pim_config_ipv4 = {}
                                  if default(get(svi, "evpn_l3_multicast.enabled"), get(vrf, "_evpn_l3_multicast_enabled")) is True:
                                      if switch_facts.get("mlag"):
                                          pim_config_ipv4["sparse_mode"] = True
                                      else:
                                          config['vlan_interfaces'][f"Vlan{svi['id']}"]["ip_igmp"] = True

                                      if "ip_address_virtual" in config['vlan_interfaces'][f"Vlan{svi['id']}"]:
                                          vrf_diagnostic_loopback = get(vrf, "vtep_diagnostic.loopback")
                                          if vrf_diagnostic_loopback is None:
                                              raise Exception(
                                                  f"No vtep_diagnostic loopback defined on VRF '{vrf['name']}' in Tenant '{tenant['name']}'."
                                                  "This is required when 'l3_multicast' is enabled on the VRF and ip_address_virtual is used on an SVI in that VRF."
                                              )
                                          pim_config_ipv4["local_interface"] = f"Loopback{vrf_diagnostic_loopback}"

                                      if pim_config_ipv4:
                                          config['vlan_interfaces'][f"Vlan{svi['id']}"]["pim"] = {"ipv4": pim_config_ipv4}

                                  # configure eos_cli statements
                                  config['vlan_interfaces'][f"Vlan{svi['id']}"]['eos_cli'] = "\n".join(svi['eos_cli'])

                          # configure vrf ibgp mlag peer interface
                          if switch_facts.get('mlag') and vrf.get('enable_mlag_ibgp_peering_vrfs'):
                              ibgp_vlan = vrf['mlag_ibgp_peering_vlan']
                              ibgp_peering_subnet = vrf['mlag_ibgp_peering_subnet']
                              ibgp_peering_subnet_mask = vrf['mlag_ibgp_peering_subnet_mask']
                              mlag_ip = str(get_mlag_ip(
                                      switch_facts,
                                      ibgp_peering_subnet,
                                      ibgp_peering_subnet_mask,
                                      switch_facts['mlag_role']
                                      )
                                  )
                              config['vlan_interfaces'][f"Vlan{ibgp_vlan}"] = {
                                  "tenant": tenant['name'],
                                  "type": "underlay_peering",
                                  "shutdown": False,
                                  "mtu": 9214,
                                  "description": f"MLAG_PEER_L3_iBGP:{vrf['name']}",
                                  "vrf": vrf['name'],
                                  "ip_address": f"{mlag_ip}/{ibgp_peering_subnet_mask}"
                              }
                              # Reset mtu to 1500 if veos
                              if re.match(veos_regex, switch_facts['platform']):
                                  config['vlan_interfaces'][f"Vlan{ibgp_vlan}"]['mtu'] = None
                              if "MLAG_VRF_PEER" not in (config['port_channel_interfaces']
                                                        [f"Port-Channel{switch_facts['mlag_port_channel_id']}"]
                                                        ['trunk_groups']):
                                  (config['port_channel_interfaces']
                                  [f"Port-Channel{switch_facts['mlag_port_channel_id']}"]
                                  ['trunk_groups']).append("MLAG_VRF_PEER")

              # Assume this is a VTEP if below criteria is met
              if switch_facts.get('vtep'):
                  # Perform vtep logic (set rds and rts)
                  ip_vrf_admin_field_key_words = {
                      "VNI": "vrf['vni']",
                      "Router-ID": "switch_facts['router_id']",
                      "VTEP Source IP": "switch_facts['vtep_ip']"
                  }
                  vlan_based_mac_vrf_admin_field_key_words = {
                      "VNI": "vlan['vni']",
                      "VLAN": "vlan['id']",
                      "Router-ID": "switch_facts['router_id']",
                      "VTEP Source IP": "switch_facts['vtep_ip']"
                  }
                  vlan_aware_mac_vrf_admin_field_key_words = {
                      "First-VLAN": "bundle['first_vlan']",
                      "First-VNI": "bundle['first_vni']",
                      "Last-VLAN": "bundle['last_vlan']",
                      "Last-VNI": "bundle['last_vni']",
                      "Router-ID": "switch_facts['router_id']",
                      "VTEP Source IP": "switch_facts['vtep_ip']"
                  }
                  for tenant in network_services_data["tenants"]:
                      # Set vrfs
                      for vrf in tenant.get("vrfs", []):
                          if vrf["name"] != "default":
                              # Set vrf rd
                              switch_rd = []
                              for rd_segment in vrf['route_distinguisher'].split(":"):
                                  if ip_vrf_admin_field_key_words.get(rd_segment):
                                      switch_rd.append(str(eval(ip_vrf_admin_field_key_words[rd_segment])))
                                  else:
                                      switch_rd.append(rd_segment)
                              vrf['route_distinguisher'] = ":".join(switch_rd)
                              # Set vrf rt
                              switch_rt = []
                              for rt_segment in vrf['route_target'].split(":"):
                                  if ip_vrf_admin_field_key_words.get(rt_segment):
                                      switch_rt.append(str(eval(ip_vrf_admin_field_key_words[rt_segment])))
                                  else:
                                      switch_rt.append(rt_segment)
                              vrf['route_target'] = ":".join(switch_rt)
                              # Set l3 multicast group
                              if vrf.get("_evpn_l3_multicast_enabled") and tenant.get("evpn_l3_multicast"):
                                  mcast_pool = tenant["evpn_l3_multicast"]["evpn_underlay_l3_multicast_group_ipv4_pool"]
                                  offset = vrf['vni'] - 1 + tenant["evpn_l3_multicast"].get("evpn_underlay_l3_multicast_group_ipv4_pool_offset", 0)
                                  underlay_group_address = get_ip(mcast_pool, 32, offset, 0)
                                  vrf["multicast_group"] = underlay_group_address
                          # Set L3 vlans
                          for vlan in vrf.get("svis", []):
                              if vlan["vxlan"]:
                                  # Set vlan rd
                                  switch_rd = []
                                  for rd_segment in vlan['route_distinguisher'].split(":"):
                                      if vlan_based_mac_vrf_admin_field_key_words.get(rd_segment) is not None:
                                          switch_rd.append(str(eval(vlan_based_mac_vrf_admin_field_key_words[rd_segment])))
                                      else:
                                          switch_rd.append(rd_segment)
                                  vlan['route_distinguisher'] = ":".join(switch_rd)
                                  # Set vlan rts
                                  switch_rt = []  # For both import/export rt

                                  for i, rt_segment in enumerate(vlan['route_target'].split(":")):
                                      if vlan_based_mac_vrf_admin_field_key_words.get(rt_segment) is not None:
                                          rt_segment = str(eval(vlan_based_mac_vrf_admin_field_key_words[rt_segment]))
                                      switch_rt.append(rt_segment)

                                  vlan['route_target'] = ":".join(switch_rt)

                                  if switch_facts.get('evpn_gateway_vxlan_l2'):
                                      vlan['rd_evpn_domain'] = {
                                          "domain": "remote",
                                          "rd": ":".join(switch_rd)
                                      }
                                      vlan['import_export_evpn_domains'] = [
                                          {
                                              "domain": "remote",
                                              "route_target": ":".join(switch_rt) if len(switch_rt) > 0 else []
                                          }
                                      ]

                      # Set l2 vlans
                      for vlan in tenant.get("l2vlans", []):
                          if vlan["vxlan"]:
                              vlan_evpn_l2_multicast_enabled = default(get(vlan, "evpn_l2_multicast.enabled"), get(tenant, "evpn_l2_multicast.enabled"))
                              if vlan_evpn_l2_multicast_enabled is True:
                                  mcast_pool = get(
                                      tenant,
                                      "evpn_l2_multicast.underlay_l2_multicast_group_ipv4_pool",
                                      required=True,
                                      org_key=f"'evpn_l2_multicast.underlay_l2_multicast_group_ipv4_pool' for Tenant: {tenant['name']}",
                                  )
                                  offset = vlan['id'] - 1 + get(tenant, "evpn_l2_multicast.underlay_l2_multicast_group_ipv4_pool_offset", default=0)
                                  underlay_group_address = get_ip(mcast_pool, 32, offset, 0)
                                  vlan["multicast_group"] = underlay_group_address

                              # Set vlan rd
                              switch_rd = []
                              for rd_segment in vlan['route_distinguisher'].split(":"):
                                  if vlan_based_mac_vrf_admin_field_key_words.get(rd_segment) is not None:
                                      switch_rd.append(str(eval(vlan_based_mac_vrf_admin_field_key_words[rd_segment])))
                                  else:
                                      switch_rd.append(rd_segment)
                              vlan['route_distinguisher'] = ":".join(switch_rd)
                              # Set vlan rt
                              switch_rt = []  # For both import/export rt
                              switch_import_rt = []  # For only import rt
                              switch_export_rt = []  # For only export rt
                              for i, rt_segment in enumerate(vlan['route_target'].split(":")):
                                  if vlan_based_mac_vrf_admin_field_key_words.get(rt_segment) is not None:
                                      rt_segment = str(eval(vlan_based_mac_vrf_admin_field_key_words[rt_segment]))
                                  # Format for etree switches
                                  if not vlan.get('etree_role'):
                                      switch_rt.append(rt_segment)
                                  else:
                                      leaf_rt_segment = str(vlan['etree_leaf_export_rt_offset'] + int(rt_segment)) if i % 2 == 1 else rt_segment
                                      if vlan["etree_role"] == 'root':
                                          switch_rt.append(rt_segment)
                                          switch_import_rt.append(leaf_rt_segment)
                                      else:
                                          switch_import_rt.append(rt_segment)
                                          switch_export_rt.append(leaf_rt_segment)
                                          switch_rt = []

                              vlan['route_target'] = ":".join(switch_rt) if len(switch_rt) > 0 else []
                              vlan['import_route_target'] = ":".join(switch_import_rt) if len(switch_import_rt) > 0 else []
                              vlan['export_route_target'] = ":".join(switch_export_rt) if len(switch_export_rt) > 0 else []
                              if switch_facts.get('evpn_gateway_vxlan_l2'):
                                  vlan['rd_evpn_domain'] = {
                                      "domain": "remote",
                                      "rd": ":".join(switch_rd)
                                  }
                                  vlan['import_export_evpn_domains'] = [
                                      {
                                          "domain": "remote",
                                          "route_target": ":".join(switch_rt) if len(switch_rt) > 0 else []
                                      }
                                  ]
                      # Set vlan_aware_bundles
                      for bundle in tenant.get('vlan_aware_bundles', []):
                          # Set bundle rd
                          switch_rd = []
                          for rd_segment in bundle['route_distinguisher'].split(":"):
                              if vlan_aware_mac_vrf_admin_field_key_words.get(rd_segment) is not None:
                                  switch_rd.append(str(eval(vlan_aware_mac_vrf_admin_field_key_words[rd_segment])))
                              else:
                                  switch_rd.append(rd_segment)
                          bundle['route_distinguisher'] = ":".join(switch_rd)
                          # Set bundle rt
                          switch_rt = []
                          for rt_segment in bundle['route_target'].split(":"):
                              if vlan_aware_mac_vrf_admin_field_key_words.get(rt_segment) is not None:
                                  switch_rt.append(str(eval(vlan_aware_mac_vrf_admin_field_key_words[rt_segment])))
                              else:
                                  switch_rt.append(rt_segment)
                          bundle['route_target'] = ":".join(switch_rt)
                          if switch_facts.get('evpn_gateway_vxlan_l2'):
                              bundle['rd_evpn_domain'] = {
                                  "domain": "remote",
                                  "rd": ":".join(switch_rd)
                              }
                              bundle['import_export_evpn_domains'] = [
                                  {
                                      "domain": "remote",
                                      "route_target": ":".join(switch_rt) if len(switch_rt) > 0 else []
                                  }
                              ]

                  # Set bgp
                  if switch_facts['network_services_l3']:
                      config['router_bgp']['vrfs'] = {}
                      config['router_bgp']['vlans'] = {}
                      config['router_bgp']['vlan_aware_bundles'] = {}
                      for tenant in network_services_data["tenants"]:
                          # Set vrfs
                          for vrf in tenant.get('vrfs', []):
                              address_family_ipv4_neighbors = []
                              address_family_ipv6_neighbors = []
                              try:
                                  if vrf['name'] == "default":
                                      route_distinguisher = None
                                      route_targets = None
                                  elif vrf['route_target'] == None:
                                      route_distinguisher = vrf['route_distinguisher']
                                      route_targets = {
                                          "import": {
                                              "evpn": []
                                          },
                                          "export": {
                                              "evpn": []
                                          }
                                      }
                                  else:
                                      route_distinguisher = vrf['route_distinguisher']
                                      route_targets = {
                                          "import": {
                                              "evpn": [vrf['route_target']]
                                          },
                                          "export": {
                                              "evpn": [vrf['route_target']]
                                          }
                                      }
                                      # additional route targets
                                      if vrf.get('additional_route_targets'):
                                          for rt in natural_sort(vrf['additional_route_targets']):
                                              if rt.get('address_family') \
                                                      and rt.get('route_target') \
                                                      and rt.get('type'):
                                                  if rt['address_family'] in route_targets[rt['type']].keys():
                                                      route_targets[rt['type']][rt['address_family']].append(rt['route_target'])
                                                  else:
                                                      route_targets[rt['type']].update({rt['address_family']: rt['route_target']})
                              except Exception as e:
                                  assert False, f"{switch_facts['hostname']} is having an issue with {vrf['name']} vrf: {e}"
                              # initialize vrf
                              config['router_bgp']['vrfs'][vrf['name']] = {
                                  "router_id": switch_facts['router_id'],
                                  "rd": route_distinguisher,
                                  "route_targets": route_targets,
                                  "neighbors": {},
                                  "redistribute_routes": {
                                      "connected": {}
                                      # "attached-host": {}
                                  },
                                  "address_families": {
                                      "ipv4": {"neighbors": {}, "networks": {}},
                                      "ipv6": {"neighbors": {}, "networks": {}}
                                  },
                                  "evpn_multicast": get(vrf, "_evpn_l3_multicast_enabled"),
                                  "eos_cli": ""
                              }
                              # get and set mlag peer config
                              if switch_facts.get('mlag') and vrf.get('enable_mlag_ibgp_peering_vrfs'):
                                  ibgp_vlan = vrf['mlag_ibgp_peering_vlan']
                                  ibgp_peering_subnet = vrf['mlag_ibgp_peering_subnet']
                                  ibgp_peering_subnet_mask = vrf['mlag_ibgp_peering_subnet_mask']
                                  mlag_peer_ip = str(get_mlag_ip(
                                          switch_facts,
                                          ibgp_peering_subnet,
                                          ibgp_peering_subnet_mask,
                                          mlag_peer_switch_facts['mlag_role']
                                          )
                                      )
                                  # Add mlag_ip to nieghbors and address family
                                  config['router_bgp']['vrfs'][vrf['name']]['neighbors'][mlag_peer_ip] = {
                                      "remote_as": switch_facts['bgp_as'],
                                      "description": mlag_peer_switch_facts['hostname'],
                                      "send_community": "all",
                                      "next_hop_self": True,
                                  }
                                  address_family_ipv4_neighbors.append(mlag_peer_ip)
                              # set external bgp peers
                              if vrf.get('bgp_peers'):
                                  for peer, peer_info in vrf['bgp_peers'].items():
                                      if validIPAddress(peer) is True:
                                          address_family_ipv4_neighbors.append(peer)
                                      elif validIPAddress(peer) is False:
                                          address_family_ipv6_neighbors.append(peer)
                                      else:
                                          continue
                                      if peer_info.get('set_ipv4_next_hop') or peer_info.get('set_ipv6_next_hop'):
                                          peer_info.update({"route_map_out": f"RM-{vrf['name']}-{peer}-SET-NEXT-HOP-OUT"})
                                          if peer_info.get('default_originate'):
                                              if not peer_info['default_originate'].get('route_map'):
                                                  peer_info['default_originate'].update(
                                                      {"route_map": f"RM-{vrf['name']}-{peer}-SET-NEXT-HOP-OUT"}
                                                  )
                                          if peer_info.get('set_ipv4_next_hop'):
                                              peer_info.pop("set_ipv4_next_hop")
                                          if peer_info.get('set_ipv6_next_hop'):
                                              peer_info.pop("set_ipv6_next_hop")
                                      config['router_bgp']['vrfs'][vrf['name']]['neighbors'][peer] = peer_info
                              # set general bgp
                              if vrf.get('bgp') and vrf['bgp'].get('raw_eos_cli'):
                                  config['router_bgp']['vrfs'][vrf['name']]['eos_cli'] = vrf['bgp']['raw_eos_cli']

                              # redistribute static routes
                              if vrf.get('redistribute_static'):
                                  config['router_bgp']['vrfs'][vrf['name']]['redistribute_routes']['static'] = {}
                              # activate neighbors for ipv4 address family
                              if len(address_family_ipv4_neighbors) > 0:
                                  for neighbor in address_family_ipv4_neighbors:
                                      config['router_bgp']['vrfs'][vrf['name']]['address_families']['ipv4']['neighbors'][neighbor] = {
                                          "activate": True
                                      }
                              else:
                                  del(config['router_bgp']['vrfs'][vrf['name']]['address_families']['ipv4'])
                              # activate neighbors for ipv6 address family
                              if len(address_family_ipv6_neighbors) > 0:
                                  for neighbor in address_family_ipv6_neighbors:
                                      config['router_bgp']['vrfs'][vrf['name']]['address_families']['ipv6']['neighbors'][neighbor] = {
                                          "activate": True
                                      }
                              else:
                                  del(config['router_bgp']['vrfs'][vrf['name']]['address_families']['ipv6'])

                              # multicast
                              evpn_multicast_transit_mode = get(vrf, "_evpn_l3_multicast_evpn_peg_transit")
                              if evpn_multicast_transit_mode is True:
                                  config['router_bgp']['vrfs'][vrf['name']]["evpn_multicast_address_family"] = {"ipv4": {"transit": evpn_multicast_transit_mode}}

                              # Set l3 vlans
                              for svi in vrf.get('svis', []):
                                  if svi['vxlan'] == False:
                                      continue
                                  vlan_in_bundle = False
                                  for bundle in tenant.get('vlan_aware_bundles', []):
                                      if svi['id'] in string_to_list(bundle['vlan_range']):
                                          vlan_in_bundle = True
                                          break
                                  if vlan_in_bundle is True:
                                      continue
                                  config['router_bgp']['vlans'][svi['id']] = {
                                      "tenant": tenant['name'],
                                      "rd": svi['route_distinguisher'],
                                      "route_targets": {},
                                      "redistribute_routes": ["learned"]
                                  }
                                  if svi.get('rd_evpn_domain'):
                                      config['router_bgp']['vlans'][svi['id']]['rd_evpn_domain'] = svi['rd_evpn_domain']
                                  # Set route targets
                                  config['router_bgp']['vlans'][svi['id']]['route_targets']['both'] = [svi['route_target']] if svi.get('route_target') else []
                                  config['router_bgp']['vlans'][svi['id']]['route_targets']['import'] = [svi['import_route_target']] if svi.get('import_route_target') else []
                                  config['router_bgp']['vlans'][svi['id']]['route_targets']['export'] = [svi['export_route_target']] if svi.get('export_route_target') else []
                                  if svi.get('import_export_evpn_domains'):
                                      config['router_bgp']['vlans'][svi['id']]['route_targets']['import_export_evpn_domains'] = svi['import_export_evpn_domains']

                          # Set l2 vlans
                          for l2vlan in tenant.get('l2vlans', []):
                              if l2vlan['vxlan'] == False:
                                  continue
                              vlan_in_bundle = False
                              for bundle in tenant.get('vlan_aware_bundles', []):
                                  if l2vlan['id'] in string_to_list(bundle['vlan_range']):
                                      vlan_in_bundle = True
                                      break
                              if vlan_in_bundle is True:
                                  continue
                              config['router_bgp']['vlans'][l2vlan['id']] = {
                                  "tenant": tenant['name'],
                                  "rd": l2vlan['route_distinguisher'],
                                  "route_targets": {},
                                  "redistribute_routes": ["learned"]
                              }
                              if l2vlan.get('rd_evpn_domain'):
                                  config['router_bgp']['vlans'][l2vlan['id']]['rd_evpn_domain'] = l2vlan['rd_evpn_domain']
                              # Set route targets
                              config['router_bgp']['vlans'][l2vlan['id']]['route_targets']['both'] = [l2vlan['route_target']] if l2vlan.get('route_target') else []
                              config['router_bgp']['vlans'][l2vlan['id']]['route_targets']['import'] = [l2vlan['import_route_target']] if l2vlan.get('import_route_target') else []
                              config['router_bgp']['vlans'][l2vlan['id']]['route_targets']['export'] = [l2vlan['export_route_target']] if l2vlan.get('export_route_target') else []
                              if l2vlan.get('import_export_evpn_domains'):
                                  config['router_bgp']['vlans'][l2vlan['id']]['route_targets']['import_export_evpn_domains'] = l2vlan['import_export_evpn_domains']

                          # Set vlan aware bundles
                          for bundle in tenant.get('vlan_aware_bundles', []):
                              config['router_bgp']['vlan_aware_bundles'][bundle['name']] = {
                                  "rd": bundle['route_distinguisher'],
                                  "route_targets": {
                                      "both": [bundle['route_target']]
                                  },
                                  "vlan": bundle['vlan_range'],
                                  "redistribute_routes": ["learned"]
                              }
                              if bundle.get('rd_evpn_domain'):
                                  config['router_bgp']['vlan_aware_bundles'][bundle['name']]['rd_evpn_domain'] = bundle['rd_evpn_domain']
                              if bundle.get('import_export_evpn_domains'):
                                  config['router_bgp']['vlan_aware_bundles'][bundle['name']]['route_targets']['import_export_evpn_domains'] = bundle['import_export_evpn_domains']


                  # Set vxlan interface
                  config['vxlan_interface'] = {"Vxlan1": {"vxlan": {"vrfs": {}, "vlans": {}}}}
                  for tenant in network_services_data["tenants"]:
                      for vrf in tenant.get('vrfs', []):
                          if vrf['name'] != "default":
                              # map vrfs to vnis
                              config['vxlan_interface']['Vxlan1']['vxlan']['vrfs'][vrf['name']] = {
                                  "vni": vrf['vni']
                              }
                              if vrf.get("multicast_group"):
                                  config['vxlan_interface']['Vxlan1']['vxlan']['vrfs'][vrf['name']]["multicast_group"] = vrf["multicast_group"]
                          # map l3vlans to vnis
                          for svi in vrf.get('svis', []):
                              if not svi.get('vni') or not svi['vxlan']:
                                  continue
                              config['vxlan_interface']['Vxlan1']['vxlan']['vlans'][svi['id']] = {
                                  "vni": svi['vni']
                              }

                      # map l2vlans to vnis
                      for l2vlan in tenant.get('l2vlans', []):
                          if not l2vlan.get('vni') or not l2vlan['vxlan']:
                              continue
                          config['vxlan_interface']['Vxlan1']['vxlan']['vlans'][l2vlan['id']] = {
                              "vni": l2vlan['vni']
                          }
                          if l2vlan.get("multicast_group"):
                              config['vxlan_interface']['Vxlan1']['vxlan']['vlans'][l2vlan['id']]["multicast_group"] = l2vlan["multicast_group"]

              # clean up unnecessary config elements
              if switch_facts.get('mlag') \
                      and config['port_channel_interfaces'].get(f"Port-Channel{switch_facts['mlag_port_channel_id']}") \
                      and len(
                          config['port_channel_interfaces'][f"Port-Channel{switch_facts['mlag_port_channel_id']}"]['trunk_groups']
                          ) == 0:
                  del(config['port_channel_interfaces'][f"Port-Channel{switch_facts['mlag_port_channel_id']}"])

              # Clear dhcp snooping config if veos
              if re.match(veos_regex, switch_facts['platform']) and config.get('ip_dhcp_snooping'):
                  del config['ip_dhcp_snooping']

              return config


          def get_tag_values_applied_to_device(tag_assignment_key):
              label = tag_assignment_key.label.value
              value = tag_assignment_key.value.value
              device_id = tag_assignment_key.device_id.value
              workspace_id = tag_assignment_key.workspace_id.value
              tsclient = ctx.getApiClient(tsgr.TagSearchStub)

              matching_tags = []

              tvsr = tspb.TagValueSearchRequest(label=label, workspace_id=workspace_id, topology_studio_request=True)
              for tag in tsclient.GetTagValueSuggestions(tvsr).tags:
                  query = f"{tag.label}:\"{tag.value}\" AND device:{device_id}"
                  tagmr = tspb.TagMatchRequestV2(query=query, workspace_id=workspace_id, topology_studio_request=True)
                  tagmresp = tsclient.GetTagMatchesV2(tagmr)
                  for match in tagmresp.matches:
                      if match.device.device_id == device_id:
                          matching_tags.append(tag)

              return matching_tags


          def get_tag_value(device_id=None, label=None, workspace_id=None):
              tag_assignment_key = TagAssignmentKey()
              tag_assignment_key.element_type = 1
              if workspace_id is not None:
                  tag_assignment_key.workspace_id.value = workspace_id
              if device_id is not None:
                  tag_assignment_key.device_id.value = device_id
              if label is not None:
                  tag_assignment_key.label.value = label
              tag_values = get_tag_values_applied_to_device(tag_assignment_key)
              if len(tag_values) > 0:
                  return tag_values[0].value


          def check_config_parameters(switch_facts):
              if switch_facts.get('vtep'):
                  assert switch_facts.get('bgp_as') is not None, f"BGP ASN is not set.  Please apply a 'router_bgp.as' tag to " \
                                                                 f"{switch_facts['hostname']} in the Tags section of Provisioning " \
                                                                 f"with the appropriate workspace selected."
                  assert switch_facts.get('router_id') is not None, f"BGP Router ID is not set.  Please apply a 'router_bgp.router_id' " \
                                                                    f"tag to {switch_facts['hostname']} in the Tags section of " \
                                                                    f"Provisioning with the appropriate workspace selected."
              if switch_facts.get('mlag') is True:
                  assert switch_facts.get('mlag_port_channel_id') is not None, f"MLAG Peer Link is not set.  Please apply a " \
                                                                               f"'mlag_configuration.peer_link' tag to " \
                                                                               f"{switch_facts['hostname']} in the Tags " \
                                                                               f"'section of Provisioning with the appropriate " \
                                                                               f"workspace selected"


          def get_interfaces_info(switch_facts):
              device_id = switch_facts['serial_number']
              interfaces = {}
              for i in ctx.topology.getDevices(deviceIds=[device_id])[0].getInterfaces():
                  peer_device, peer_interface = i.getPeerInfo()
                  if peer_device is not None and "Ethernet" in i.name:
                      interfaces[i.name] = {
                          "neighborId": peer_device.id,
                          "neighborHostname": peer_device.hostName,
                          "neighborInterface": peer_interface.name
                      }
              return interfaces


          def get_mlag_peer(switch_facts):
              mlag_peer_switch_serial_number = None
              if switch_facts.get('mlag'):
                  # Get MLAG peer from interface's neighbor details
                  # Look for DC data center tags to get MLAG peer
                  if switch_facts.get('type') and switch_facts.get('dc') and switch_facts.get('pod'):
                      for info in switch_facts['interfaces'].values():
                          neighbor_switch_facts = get_switch_basics_from_tags(info['neighborId'])
                          if neighbor_switch_facts.get('mlag') and \
                                  neighbor_switch_facts.get('type', '') == switch_facts.get('type') and \
                                  neighbor_switch_facts.get('dc', '') == switch_facts.get('dc') and \
                                  neighbor_switch_facts.get('pod', '') == switch_facts.get('pod'):
                              mlag_peer_switch_serial_number = neighbor_switch_facts['serial_number']
                              return mlag_peer_switch_serial_number
                  # Look for campus tags to get MLAG peer
                  if switch_facts.get('type') and switch_facts.get('campus') and switch_facts.get('site'):
                      for info in switch_facts['interfaces'].values():
                          neighbor_switch_facts = get_switch_basics_from_tags(info['neighborId'])
                          if neighbor_switch_facts.get('mlag') and \
                                  neighbor_switch_facts.get('type', '') == switch_facts.get('type') and \
                                  neighbor_switch_facts.get('campus', '') == switch_facts.get('campus') and \
                                  neighbor_switch_facts.get('site', '') == switch_facts.get('site'):
                              mlag_peer_switch_serial_number = neighbor_switch_facts['serial_number']
                              return mlag_peer_switch_serial_number
                  # If mlag peer is still not found, use 'universal' tags
                  # Assumption is that this switch's MLAG peer should be the only neighbor switch with
                  # mlag enabled, the same services running, and a node id difference of 1
                  for info in switch_facts['interfaces'].values():
                      neighbor_switch_facts = get_switch_basics_from_tags(info['neighborId'])
                      if neighbor_switch_facts.get('mlag') \
                              and switch_facts['network_services_l2'] == neighbor_switch_facts['network_services_l2'] \
                              and switch_facts['network_services_l3'] == neighbor_switch_facts['network_services_l3'] \
                              and switch_facts.get('id') and neighbor_switch_facts.get('id') \
                              and abs(int(switch_facts['id']) - int(neighbor_switch_facts['id'])) == 1:
                          mlag_peer_switch_serial_number = neighbor_switch_facts['serial_number']
                          return mlag_peer_switch_serial_number
              return mlag_peer_switch_serial_number


          def get_gateway_switches(switch_facts):
              gateway_switches = []
              # Shouldn't have to worry about uplink switches on l3 switches since they
              # are the gateway in this context
              if switch_facts['network_services_l2']:
                  # if the switch has l3 network services tag, we assume it is the gateway
                  if switch_facts['network_services_l3']:
                      gateway_switches = [switch_facts['serial_number']]
                  # if the switch does NOT have l3 network services tag, we assume it needs to find a gateway
                  else:
                      # Get uplink switches using neighbor details
                      uplink_switches = []
                      for info in switch_facts['interfaces'].values():
                          neighbor_switch_facts = get_switch_basics_from_tags(info['neighborId'])
                          if neighbor_switch_facts['network_services_l3']:
                              uplink_switches.append(neighbor_switch_facts)
                      # Assume switch is a campus pod member switch in an L2 campus topology if it has no L3
                      # uplink switches and that both neighbors are uplink switches (very use-case specific code)
                      if len(uplink_switches) == 0:
                          for info in switch_facts['interfaces'].values():
                              neighbor_switch_facts = get_switch_basics_from_tags(info['neighborId'])
                              if neighbor_switch_facts:
                                  uplink_switches.append(neighbor_switch_facts)
                      for uplink_switch_facts in uplink_switches:
                          if uplink_switch_facts['network_services_l3']:
                              gateway_switches.append(uplink_switch_facts['serial_number'])
                          else:
                              uplink_switch_facts['interfaces'] = get_interfaces_info(uplink_switch_facts)
                              uplink_gateway_switches = get_switch_basics_from_tags(uplink_switch_facts)
                              for switch_sn in uplink_gateway_switches:
                                  if switch_sn not in gateway_switches:
                                      gateway_switches.append(switch_sn)
              return gateway_switches


          def get_switch_basics_from_tags(device_id):
              switch_facts = {"serial_number": device_id}
              tags_to_facts = {
                  "hostname": "hostname",
                  "model": "platform"

              }

              for dev in ctx.topology.getDevices(deviceIds=[device_id]):
                  if dev.hostName:
                      switch_facts[tags_to_facts["hostname"]] = dev.hostName
                  if dev.modelName:
                      switch_facts[tags_to_facts["model"]] = dev.modelName

              # Set role if one exists
              roles_applied_to_switch = role_dict.get(device_id)
              if roles_applied_to_switch and len(roles_applied_to_switch) > 0:
                  switch_facts['type'] = roles_applied_to_switch[0]
              else:
                  switch_facts['type'] = None

              # Set node_id from NodeId tag
              switch_facts['id'] = node_id_dict.get(device_id)
              # If NodeId tag isn't set, check for old leaf-number or spine-number tags
              if switch_facts.get('id') is None and switch_facts.get('type') in ["Leaf", "Spine"]:
                  id_tag_type = {"Leaf": "Leaf-Number", "Spine": "Spine-Number", "Super-Spine": None}
                  node_id = get_tag_value(device_id=device_id, label=id_tag_type[switch_facts['type']], workspace_id=workspace_id)
                  if node_id is not None:
                      switch_facts['id'] = int(node_id)

              # Set network_services
              if network_services_dict.get(device_id):
                  # Set l2 network_services
                  if 'L2' in network_services_dict.get(device_id):
                      switch_facts['network_services_l2'] = True
                  else:
                      switch_facts['network_services_l2'] = False
                  # Set l3 network_services
                  if 'L3' in network_services_dict.get(device_id):
                      switch_facts['network_services_l3'] = True
                  else:
                      switch_facts['network_services_l3'] = False

              # Set l3 network services if not already set
              if not switch_facts.get('network_services_l3'):
                  if switch_facts.get('type') in ["Leaf", "Spine", "Super-Spine"]:
                      switch_facts['network_services_l3'] = True
                  else:
                      switch_facts['network_services_l3'] = False
              # Set l2 network services if not already set
              if not switch_facts.get('network_services_l2'):
                  if switch_facts.get('type') in ["Leaf", "L2-Leaf"]:
                      switch_facts['network_services_l2'] = True
                  else:
                      switch_facts['network_services_l2'] = False

              # normalize vtep
              if vtep_dict.get(device_id):
                  if re.match(r'true', vtep_dict[device_id], flags=re.IGNORECASE):
                      switch_facts['vtep'] = True
                  else:
                      switch_facts['vtep'] = False
              else:
                  if switch_facts.get('type') and switch_facts['type'] in ['Leaf']:
                      switch_facts['vtep'] = True
                  else:
                      switch_facts['vtep'] = False

              # set vtep source ip
              switch_facts['vtep_ip'] = vtep_ip_dict.get(device_id, None)

              # Set BGP ASN
              switch_facts['bgp_as'] = bgp_as_dict[device_id] if bgp_as_dict.get(device_id) else None

              # Set Router ID
              switch_facts['router_id'] = router_id_dict[device_id] if router_id_dict.get(device_id) else None

              # normalize mlag_port_channel_id and turn mlag on/off
              if mlag_peer_link_dict.get(device_id) and mlag_peer_link_dict[device_id].strip() != "":
                  switch_facts['mlag_port_channel_id'] = "".join(re.findall(r'\d', mlag_peer_link_dict[device_id]))
                  switch_facts['mlag'] = True
              else:
                  switch_facts['mlag'] = False

              # Set other keys
              if switch_facts.get('network_services_l3'):
                  switch_facts['uplink_type'] = "p2p"
              else:
                  switch_facts['uplink_type'] = "port-channel"

              # Set additional 'good to have' tags
              switch_facts['dc'] = dc_dict.get(device_id)
              switch_facts['pod'] = pod_dict.get(device_id)
              switch_facts['campus'] = campus_dict.get(device_id)
              switch_facts['site'] = site_dict.get(device_id)

              return switch_facts


          def set_fabric_variables():
              '''
              Updates global fabric_variables variable with custom settings
              '''
              custom_fabric_variables = advancedSettings
              # Update BGP variables
              if custom_fabric_variables['bgpPeerGroupSettings']['evpnOverlayCorePeerGroup']['name']:
                  fabric_variables['bgp_peer_groups']['EVPN_OVERLAY_CORE']['name'] \
                      = custom_fabric_variables['bgpPeerGroupSettings']['evpnOverlayCorePeerGroup']['name']
              if custom_fabric_variables['bgpPeerGroupSettings']['evpnOverlayCorePeerGroup']['password']:
                  fabric_variables['bgp_peer_groups']['EVPN_OVERLAY_CORE']['password'] \
                      = custom_fabric_variables['bgpPeerGroupSettings']['evpnOverlayCorePeerGroup']['password']


          def set_switch_facts(switch_facts):
              # Get interface info from studio topology tags
              switch_facts['interfaces'] = get_interfaces_info(switch_facts)

              # Get gateway details
              switch_facts['gateway_switches'] = get_gateway_switches(switch_facts)

              # Set mlag relevant facts
              switch_facts['mlag_role'] = None
              if switch_facts.get('mlag'):
                  if mlag_peer_sn := get_mlag_peer(switch_facts):
                      switch_facts['mlag_peer_serial_number'] = mlag_peer_sn
                      mlag_peer_switch_facts = get_switch_basics_from_tags(switch_facts['mlag_peer_serial_number'])
                      if int(switch_facts['id']) < int(mlag_peer_switch_facts['id']):
                          switch_facts['mlag_role'] = "primary"
                          switch_facts['mlag_primary_id'] = int(switch_facts['id'])
                      else:
                          switch_facts['mlag_role'] = "secondary"
                          switch_facts['mlag_primary_id'] = int(mlag_peer_switch_facts['id'])

              # Set switch.evpn_gateway
              if switch_facts.get("vtep"):
                  # attempt to resolve EVPN GW
                  evpn_gw_details = evpnGatewayVteps.resolve(device=switch_facts['serial_number'])
                  if evpn_gw_details and len(evpn_gw_details['remoteEvpnGatewayVtepsDetails']['remoteEvpnGatewayVtepPeers']) > 0:
                      switch_facts['evpn_gateway_vxlan_l2'] = evpn_gw_details['remoteEvpnGatewayVtepsDetails']['evpnL2']['enable']
                      switch_facts['evpn_gateway_vxlan_l3'] = evpn_gw_details['remoteEvpnGatewayVtepsDetails']['evpnL3']['enable']
                      switch_facts['evpn_gateway_vxlan_l3_inter_domain'] = evpn_gw_details['remoteEvpnGatewayVtepsDetails']['evpnL3']['interDomain']
                      if switch_facts['evpn_gateway_vxlan_l2'] or switch_facts['evpn_gateway_vxlan_l3']:
                          switch_facts['evpn_gateway_remote_peers'] = evpn_gw_details['remoteEvpnGatewayVtepsDetails']['remoteEvpnGatewayVtepPeers']

              return switch_facts


          # returns dictionary of device to label value based on workspace tag assignments
          def populate_single_value_dict(workspace_id, label):
              sv_dict = {}
              tsclient = ctx.getApiClient(tsgr.TagSearchStub)
              tvsr = tspb.TagValueSearchRequest(
                  label=label,
                  workspace_id=workspace_id,
                  topology_studio_request=True
              )
              for tag in tsclient.GetTagValueSuggestions(tvsr).tags:
                  query = f"{tag.label}:\"{tag.value}\""
                  tagmr = tspb.TagMatchRequestV2(
                      query=query,
                      workspace_id=workspace_id,
                      topology_studio_request=True
                  )
                  tagmresp = tsclient.GetTagMatchesV2(tagmr)
                  for match in tagmresp.matches:
                      sv_dict[match.device.device_id] = tag.value
              return sv_dict


          # returns dictionary of device to label values based on workspace tag assignments
          def populate_multi_value_dict(workspace_id, label):
              mv_dict = {}
              tsclient = ctx.getApiClient(tsgr.TagSearchStub)
              tvsr = tspb.TagValueSearchRequest(
                  label=label,
                  workspace_id=workspace_id,
                  topology_studio_request=True
              )
              for tag in tsclient.GetTagValueSuggestions(tvsr).tags:
                  query = f"{tag.label}:\"{tag.value}\""
                  tagmr = tspb.TagMatchRequestV2(
                      query=query,
                      workspace_id=workspace_id,
                      topology_studio_request=True
                  )
                  tagmresp = tsclient.GetTagMatchesV2(tagmr)
                  for match in tagmresp.matches:
                      mv_dict.setdefault(match.device.device_id, []).append(tag.value)
              return mv_dict


          def clean_config(config):
              # remove default vrf dictionary
              if config.get('vrfs') and config['vrfs'].get('default'):
                  del config['vrfs']['default']
              # remove any empty SVIs
              svis_to_delete = []
              for svi, info in config['vlan_interfaces'].items():
                  if len(info.keys()) == 0:
                      svis_to_delete.append(svi)
              for svi in svis_to_delete:
                  del config['vlan_interfaces'][svi]

              # remove default vrf from L3 vrfs in bgp config
              if config.get('router_bgp') and config['router_bgp'].get('vrfs') and config['router_bgp']['vrfs'].get('default'):
                  del config['router_bgp']['vrfs']['default']

              # remove default router_multicast dictionary
              if len(config.get("router_multicast", {}).get("vrfs", [])) == 0:
                  del config['router_multicast']
              # remove default router_pim_sparse_mode dictionary
              if len(config.get("router_pim_sparse_mode", {}).get("vrfs", [])) == 0:
                  del config['router_pim_sparse_mode']

              return config


          def device_matches_resolver_query(resolver, device_id):
              _, ctx_resolver = resolver.resolveWithContext(device_id)
              if ctx_resolver and ctx_resolver.query_str.strip() != "":
                  return True
              else:
                  return False


          def get_network_services_applied_to_switch(switch_facts, tenants):
              # device_id from switch_facts
              device_id = switch_facts['serial_number']

              switch_facts['tenants'] =  {}
              switch_facts['vlans'] =  []

              # Set services
              if switch_facts["network_services_l2"] is True and switch_facts["network_services_l3"] is True:
                  # allow all vlans
                  # switch_facts["allow_all_vlans"] = site_details["services"].get("allowAllVLANs", False)

                  switch_services = {
                      "vlans": [],
                      "tenants": {}
                  }
                  for tenant in tenants:
                      # ctx.info(f"{tenant}")
                      add_vrfs = {}  # Used to determine which services are applied to this switch
                      for vrf in tenant['vrfs']:
                          # ctx.info(f"{vrf['name']}")
                          # if vrf is manually assigned to devices
                          if device_matches_resolver_query(vrf['devices'], device_id):
                              add_vrfs[vrf['name']] = {
                                  "svis": []
                              }
                              # ctx.info(f"Adding {vrf['name']} because found it in applied devices list")
                              continue

                          # if l3 interface is to be configured on switch
                          if len(vrf.get('l3Interfaces').resolve(device=device_id)['interfaces']) > 0:
                              if device_matches_resolver_query(vrf['l3Interfaces'], device_id):
                                  add_vrfs[vrf['name']] = {
                                      "svis": []
                                  }
                                  # ctx.info(f"Adding {vrf['name']} because found an l3 interface")
                                  continue

                          # Add VRF if there is a BGP neighbor for this node in vrf
                          for bgp_peer in vrf.get("externalBgpPeers", []):
                              # if bgp peer is to be configured on switch
                              if device_matches_resolver_query(bgp_peer['devices'], device_id):
                                  add_vrfs[vrf['name']] = {
                                      "svis": []
                                  }
                                  # ctx.info(f"Adding {vrf['name']} because found an ebgp peer")
                                  break

                          if add_vrfs.get(vrf['name']):
                              continue

                          # Add VRF if there is a static route for this node in vrf
                          for sr in vrf.get('staticRoutes', []):
                              # if static route is to be configured on switch
                              if device_matches_resolver_query(sr['devices'], device_id):
                                  add_vrfs[vrf['name']] = {
                                      "svis": []
                                  }
                                  # ctx.info(f"Adding {vrf['name']} because found a static route")
                                  break

                          if add_vrfs.get(vrf['name']):
                              continue

                          # Add VRF if there are extra route targets
                          for rt in vrf.get('additionalRouteTargets', []):
                              # if static route is to be configured on switch
                              if device_matches_resolver_query(rt['devices'], device_id):
                                  add_vrfs[vrf['name']] = {
                                      "svis": []
                                  }
                                  # ctx.info(f"Adding {vrf['name']} because found an addition rt")
                                  break

                          # Last check in loop is unnecessary
                          if add_vrfs.get(vrf['name']):
                              continue

                      # Add vlans
                      add_l2vlans = []
                      for vlan in tenant["vlans"]:
                          # Check if vlan is applied to switch
                          if device_matches_resolver_query(vlan['switches'], device_id):
                              if vlan.get('l3OrL2') and vlan['l3OrL2'] is True:
                                  switch_services['vlans'].append(int(vlan['vlanId']))
                                  if vlan.get('vrf', '') == '':
                                      vrf_name = 'default'
                                  else:
                                      vrf_name = vlan['vrf']

                                  # Add vrf to add_vrfs
                                  if not add_vrfs.get(vrf_name):
                                      add_vrfs[vrf_name] = {
                                          "svis": []
                                      }

                                  # Add vlan to vrf's svis
                                  add_vrfs[vrf_name]["svis"].append(int(vlan['vlanId']))
                              else:
                                  add_l2vlans.append(int(vlan['vlanId']))
                                  switch_services['vlans'].append(int(vlan['vlanId']))

                      # add vlan aware bundles
                      add_vlan_aware_bundles = []
                      for vlan_aware_bundle in tenant["vlanAwareBundles"]:
                          add_bundle = False
                          for vlan in switch_services['vlans']:
                              if vlan in string_to_list(vlan_aware_bundle["vlanRange"]):
                                  add_bundle = True
                                  break
                          if add_bundle:
                              add_vlan_aware_bundles.append(vlan_aware_bundle['name'])

                      # Filter only services applied to this switch
                      if len(add_vrfs) > 0 or len(add_l2vlans) > 0:
                          switch_services['tenants'].update({ tenant['name']: {"vrfs": add_vrfs, "l2vlans": add_l2vlans, "vlan_aware_bundles": add_vlan_aware_bundles} })

                  switch_facts['tenants'] =  switch_services['tenants']
                  switch_facts['vlans'] =  switch_services['vlans']

              return switch_facts


          def get_tenants(switch_facts, tenants):
              '''
              Converts studios input schema to avd network services schema:
              AVD tenant data model - https://avd.sh/en/stable/roles/eos_designs/doc/network-services.html
              '''
              # device_id from switch_facts
              device_id = switch_facts["serial_number"]

              tenants_data_model = {}
              for tenant in tenants:
                  vlans_in_tenant = tenant["vlans"]
                  vlan_aware_bundles_in_tenant = tenant["vlanAwareBundles"]

                  tenant_name = tenant['name']
                  tenant_data_model = {
                      'mac_vrf_vni_base': tenant['macVrfVniBase'],
                      'vrfs': {
                          'default': {
                              'error_name': 'default',
                              'svis': {}
                          }
                      },
                      'l2vlans': {},
                      'vlan_aware_bundles': {}
                  }

                  if tenant.get('evpnMulticast') is not None:
                      # Check to see if l2 evpn multicast is enabled
                      if tenant['evpnMulticast'].get('l2Multicast') is not None:
                          if tenant['evpnMulticast']['l2Multicast'].get("enabled", "No") == "Yes":
                              l2_mcast_inputs = tenant['evpnMulticast']["l2Multicast"]
                              tenant_data_model["evpn_l2_multicast"] = {
                                  "enabled": True,
                                  "underlay_l2_multicast_group_ipv4_pool": l2_mcast_inputs.get("evpnUnderlayMulticast", {}).get('evpnUnderlayL2MulticastGroupIpv4Pool'),
                                  "underlay_l2_multicast_group_ipv4_pool_offset": l2_mcast_inputs.get("evpnUnderlayMulticast", {}).get('evpnUnderlayL2MulticastGroupIpv4PoolOffset')
                              }
                      # Check to see if l3 evpn multicast is enabled
                      if tenant['evpnMulticast'].get('l3Multicast') is not None:
                          if tenant['evpnMulticast']['l3Multicast'].get("enabled", "No") == "Yes":
                              l3_mcast_inputs = tenant['evpnMulticast']["l3Multicast"]
                              tenant_data_model["evpn_l3_multicast"] = {
                                  "enabled": True,
                                  "evpn_underlay_l3_multicast_group_ipv4_pool": l3_mcast_inputs.get("evpnUnderlayMulticast", {}).get('evpnUnderlayL3MulticastGroupIpv4Pool'),
                                  "evpn_underlay_l3_multicast_group_ipv4_pool_offset": l3_mcast_inputs.get("evpnUnderlayMulticast", {}).get('evpnUnderlayL3MulticastGroupIpv4PoolOffset')
                              }
                              if l3_mcast_inputs.get('evpnPeg') and device_matches_resolver_query(l3_mcast_inputs['evpnPeg'], device_id):
                                  evpn_peg = {
                                      "nodes": [device_id]
                                  }
                                  if l3_mcast_inputs['evpnPeg'].resolve(device=device_id).get("transit", "") != "":
                                      evpn_peg["transit"] = True if l3_mcast_inputs['evpnPeg'].resolve(device=device_id)["transit"] == "Yes" else False
                                  tenant_data_model["evpn_l3_multicast"]["evpn_peg"] = [evpn_peg]
                              rp_groups = []
                              for rp_group in l3_mcast_inputs.get("pimRpAddresses", []):
                                  if len(rp_group.get("rpIpAddresses", [])) > 0:
                                      rp_group_info = {
                                          "rps": rp_group["rpIpAddresses"]
                                      }
                                      if len(rp_group.get("groupAddresses", [])) > 0:
                                          rp_group_info["groups"] = rp_group["groupAddresses"]
                                      rp_groups.append(rp_group_info)
                              if len(rp_groups) > 0:
                                  tenant_data_model["pim_rp_addresses"] = rp_groups

                  for vrf in tenant['vrfs']:
                      vrf_name = vrf["name"]
                      tenant_data_model["vrfs"][vrf_name] = {
                          "error_name": vrf_name,
                          "svis": {}
                      }
                      tenant_data_model["vrfs"][vrf_name]["vni"] = vrf["vni"]
                      if switch_facts["network_services_l2"] and switch_facts["network_services_l3"]:
                          # mlag l3 peering
                          if vrf.get("iBgpDetails") and vrf["iBgpDetails"].get("iBgpVlanId") is not None and switch_facts.get('mlag_role') is not None:
                              tenant_data_model["vrfs"][vrf_name]["mlag_ibgp_peering_vlan"] = vrf["iBgpDetails"]["iBgpVlanId"]
                              if vrf["iBgpDetails"].get("iBgpSubnet", "") != "":
                                  mlag_peer_l3_ipv4_pool = vrf["iBgpDetails"]["iBgpSubnet"]
                                  mlag_peer_l3_subnet_mask = vrf["iBgpDetails"].get('iBgpSubnetMask', 31)
                                  if switch_facts["mlag_role"] == "primary":
                                      mlag_l3_ip = str(get_mlag_ip(switch_facts, mlag_peer_l3_ipv4_pool,
                                                                                  mlag_peer_l3_subnet_mask, "primary"))

                                      mlag_peer_l3_ip = str(get_mlag_ip(switch_facts, mlag_peer_l3_ipv4_pool,
                                                                                      mlag_peer_l3_subnet_mask, "secondary"))

                                  else:
                                      mlag_l3_ip = str(get_mlag_ip(switch_facts, mlag_peer_l3_ipv4_pool,
                                                                                  mlag_peer_l3_subnet_mask, "secondary"))

                                      mlag_peer_l3_ip = str(get_mlag_ip(switch_facts, mlag_peer_l3_ipv4_pool,
                                                                                      mlag_peer_l3_subnet_mask, "primary"))

                                  tenant_data_model["vrfs"][vrf_name]["enable_mlag_ibgp_peering_vrfs"] = True
                                  tenant_data_model["vrfs"][vrf_name]["mlag_ibgp_peering_subnet"] = mlag_peer_l3_ipv4_pool
                                  tenant_data_model["vrfs"][vrf_name]["mlag_ibgp_peering_subnet_mask"] = mlag_peer_l3_subnet_mask
                                  tenant_data_model["vrfs"][vrf_name]["mlag_l3_ip"] = mlag_l3_ip
                                  tenant_data_model["vrfs"][vrf_name]["mlag_peer_l3_ip"] = mlag_peer_l3_ip
                                  tenant_data_model["vrfs"][vrf_name]["mlag_peer_l3_subnet_mask"] = mlag_peer_l3_subnet_mask

                      if switch_facts["network_services_l3"]:
                          # source nat interface
                          if vrf['natSourceDetails'].get('natInterface', "").strip() != "":
                              # ctx.info(f"{vrf['natSourceDetails']}")
                              nat_subnet = vrf['natSourceDetails']['campus'].resolve(
                                  device=device_id)['site'].resolve(
                                  device=device_id)['subnet']
                              if not nat_subnet or nat_subnet.strip() == "":
                                  nat_subnet = vrf['natSourceDetails']['dataCenter'].resolve(
                                      device=device_id)['dcPoD'].resolve(
                                      device=device_id)['subnet']
                              if nat_subnet and nat_subnet.strip() != "":
                                  tenant_data_model["vrfs"][vrf_name]['vtep_diagnostic'] = {
                                      "loopback": "".join(re.findall(r'\d', vrf['natSourceDetails']['natInterface'])),
                                      "loopback_ip_range": nat_subnet
                                  }

                          # static routes
                          if len(vrf.get("staticRoutes", [])) > 0:
                              tenant_data_model["vrfs"][vrf_name]["static_routes"] = []
                              for sr in vrf.get("staticRoutes", []):
                                  if device_matches_resolver_query(sr["devices"], device_id):
                                      # ctx.info(f"SR: {sr}")
                                      static_route = {
                                          "destination_address_prefix": sr["routeDetails"]["destinationAddressPrefix"],
                                          "name": sr["description"].replace(" ", "_"),
                                          "nodes": [device_id]
                                      }
                                      # gateway
                                      if sr["routeDetails"].get("gateway", "") == "":
                                          static_route["gateway"] = None
                                      else:
                                          static_route["gateway"] = sr["routeDetails"]["gateway"]
                                      # interface
                                      if sr["routeDetails"].get("interface", "") == "":
                                          static_route["interface"] = None
                                      else:
                                          static_route["interface"] = sr["routeDetails"]["interface"]
                                      # distance
                                      if sr["routeDetails"].get("distance", "") == "":
                                          static_route["distance"] = None
                                      else:
                                          static_route["distance"] = sr["routeDetails"]["distance"]
                                      # tag
                                      if sr["routeDetails"].get("tag", "") == "":
                                          static_route["tag"] = None
                                      else:
                                          static_route["tag"] = sr["routeDetails"]["tag"]
                                      # metric
                                      if sr["routeDetails"].get("metric", "") == "":
                                          static_route["metric"] = None
                                      else:
                                          static_route["metric"] = sr["routeDetails"]["metric"]

                                      tenant_data_model["vrfs"][vrf_name]["static_routes"].append(static_route)

                          # redistribute static routes
                          if vrf['redistributeStaticRoutes']:
                              tenant_data_model['vrfs'][vrf_name]['redistribute_static'] = vrf['redistributeStaticRoutes']

                          # l3 interfaces
                          if vrf.get("l3Interfaces") and device_matches_resolver_query(vrf["l3Interfaces"], device_id):
                              # Create l3_interfaces list in tenant vrf if it doesn't already exist
                              if not tenant_data_model["vrfs"][vrf_name].get("l3_interfaces"):
                                  tenant_data_model["vrfs"][vrf_name]["l3_interfaces"] = []
                              # Populate l3_interfaces list in tenant vrf with user input l3 interfaces
                              for l3_interface in vrf['l3Interfaces'].resolve(device=device_id).get("interfaces", []):
                                  # ctx.info(f"{l3_interface}")
                                  interface = {}
                                  interface["interfaces"] = [l3_interface["name"]]
                                  interface["nodes"] = [switch_facts["serial_number"]]
                                  interface["ip_addresses"] = [l3_interface["ipAddress"]]
                                  interface["enabled"] = l3_interface["enabled"]
                                  if l3_interface.get("description", "") != "":
                                      interface["description"] = l3_interface["description"]
                                  if l3_interface.get("mtu"):
                                      interface["mtu"] = l3_interface["mtu"]
                                  if len(l3_interface.get("eosCli", [])) > 0:
                                      interface["raw_eos_cli"] = "\n".join(l3_interface["eosCli"])  # will use this method when extended text input type is available
                                  # Check ospf
                                  if l3_interface.get("ospf"):
                                      ospf = {
                                          "enabled": l3_interface["ospf"]["enabled"],
                                          "point_to_point": l3_interface["ospf"]["pointToPoint"],
                                          "area": l3_interface["ospf"].get("area", "0"),
                                          "cost": l3_interface["ospf"].get("cost"),
                                      }
                                      # ospf authentication
                                      if l3_interface["ospf"].get("authentication", "") != "":
                                          ospf["authentication"] = l3_interface["ospf"]["authentication"]
                                      # ospf simple auth key
                                      if l3_interface["ospf"].get("simpleAuthKey", "") != "":
                                          ospf["simpleAuthKey"] = l3_interface["ospf"]["simpleAuthKey"]
                                      # ospf message digest keys
                                      if len(l3_interface["ospf"].get("messageDigestKeys", [])) > 0:
                                          ospf["message_digest_keys"] = []
                                          for mdk in l3_interface["ospf"]["messageDigestKeys"]:
                                              ospf["message_digest_keys"].append({
                                                  "id": mdk.get("id"),
                                                  "hash_algorithm": mdk.get("hashAlgorithm"),
                                                  "key": mdk.get("key"),
                                              })
                                      interface["ospf"] = ospf

                                  # Added for subinterfaces
                                  l3_interface['encapsulation_dot1q_vlan'] = None

                                  # add interface
                                  tenant_data_model["vrfs"][vrf_name]["l3_interfaces"].append(interface)

                          # external bgp peers
                          if len(vrf.get('externalBgpPeers', {})) > 0:
                              tenant_data_model["vrfs"][vrf_name]['bgp_peers'] = {}
                              for bgp_peer in vrf.get('externalBgpPeers', {}):
                                  # check if bgp peer is to be configured on switch
                                  if device_matches_resolver_query(bgp_peer['devices'], device_id):
                                      # ctx.info(f"{bgp_peer}")
                                      peer = {}
                                      peer['remote_as'] = bgp_peer['remoteAs']
                                      if bgp_peer.get('description') and bgp_peer['description'].strip() != "":
                                          peer['description'] = bgp_peer['description']
                                      if bgp_peer.get('password', '').strip() != "":
                                          peer['password'] = bgp_peer['password']
                                      if bgp_peer.get('sendCommunity', '').strip() != "":
                                          peer['send_community'] = bgp_peer['sendCommunity']
                                      if bgp_peer.get('nextHopSelf', '').strip() != "":
                                          peer['next_hop_self'] = bgp_peer['nextHopSelf']
                                      if bgp_peer.get('maxRoutes') and bgp_peer['maxRoutes'].get('maximumRoutes'):
                                          peer['maximum_routes'] = bgp_peer['maxRoutes']['maximumRoutes']
                                      if bgp_peer.get('maxRoutes') and bgp_peer['maxRoutes'].get('warningLimit'):
                                          peer['maximum_routes_warning_limit'] = bgp_peer['maxRoutes']['warningLimit']
                                      if bgp_peer.get('defaultOriginate') and bgp_peer['defaultOriginate'].get('ebgpPeerDefaultOriginateEnable'):
                                          peer['default_originate'] = {
                                              "always": bgp_peer['defaultOriginate']['always']
                                          }
                                      if bgp_peer.get('updateSource', '').strip() != "":
                                          peer['update_source'] = bgp_peer['updateSource']
                                      if bgp_peer.get('ebgpMultihop'):
                                          peer['ebgp_multihop'] = bgp_peer['ebgpMultihop']

                                      if bgp_peer.get('nextHop') and bgp_peer['nextHop'].get('iPv4NextHop', '').strip() != "":
                                          peer['set_ipv4_next_hop'] = bgp_peer['nextHop']['iPv4NextHop']
                                      if bgp_peer.get('nextHop') and bgp_peer['nextHop'].get('iPv6NextHop', '').strip() != "":
                                          peer['set_ipv6_next_hop'] = bgp_peer['nextHop']['iPv6NextHop']
                                      if bgp_peer.get('routeMap') and bgp_peer['routeMap'].get('routeMapOut', '').strip() != "":
                                          peer['route_map_out'] = bgp_peer['routeMap']['routeMapOut']
                                      if bgp_peer.get('routeMap') and bgp_peer['routeMap'].get('routeMapIn', '').strip() != "":
                                          peer['route_map_in'] = bgp_peer['routeMap']['routeMapIn']
                                      if bgp_peer.get('weight'):
                                          peer['weight'] = bgp_peer['weight']
                                      if bgp_peer.get('localAs'):
                                          peer['local_as'] = bgp_peer['localAs']

                                      tenant_data_model["vrfs"][vrf_name]['bgp_peers'][bgp_peer['neighborIpAddress']] = peer

                          # normalize bgp
                          tenant_data_model["vrfs"][vrf_name]["bgp"] = {}
                          if len(vrf['bgp'].get('eosCli', [])) > 0:
                              tenant_data_model["vrfs"][vrf_name]["bgp"]['raw_eos_cli'] = vrf['bgp']['eosCli']

                          # additional route targets
                          additional_route_targets = []
                          for rt in vrf['additionalRouteTargets']:
                              # if additional route target is to be configured on switch
                              if device_matches_resolver_query(rt['devices'], device_id):
                                  # ctx.info(f"{rt}")
                                  route_target = {}
                                  route_target['type'] = rt['type']
                                  route_target['address_family'] = rt['addressFamily']
                                  route_target['route_target'] = rt['routeTarget']
                                  route_target['nodes'] = [device_id]
                                  additional_route_targets.append(route_target)

                          if len(additional_route_targets) > 0:
                              tenant_data_model['vrfs'][vrf_name]['additional_route_targets'] = additional_route_targets

                          # ospf configuration
                          if vrf.get("vrfOspfConfiguration") and vrf["vrfOspfConfiguration"].get("vrfOspfEnabled"):
                              # ctx.info(f"{vrf['vrfOspfConfiguration']}")
                              ospf = {"enabled": True}
                              # process_id
                              if vrf["vrfOspfConfiguration"].get("vrfOspfProcessId") is not None:
                                  ospf["process_id"] = vrf["vrfOspfConfiguration"]["vrfOspfProcessId"]
                              else:
                                  ospf["process_id"] = switch_facts["underlay_ospf_process_id"]
                              # max lsa
                              if vrf["vrfOspfConfiguration"].get("vrfOspfMaxLsa") is not None:
                                  ospf["max_lsa"] = vrf["vrfOspfConfiguration"]["vrfOspfMaxLsa"]
                              else:
                                  ospf["max_lsa"] = switch_facts["underlay_ospf_max_lsa"]
                              # bfd
                              if vrf["vrfOspfConfiguration"].get("vrfOspfBfd", "") != "":
                                  ospf["bfd"] = True if vrf["vrfOspfConfiguration"]["vrfOspfBfd"] == "Yes" else False
                              else:
                                  ospf["bfd"] = switch_facts["underlay_ospf_bfd_enable"]
                              # add ospf details to vrf
                              tenant_data_model["vrfs"][vrf_name]["ospf"] = ospf

                          # evpn multicast
                          if vrf.get("evpnMulticast", {}).get("enabled", "").strip() != "":
                              l3_mcast_enabled = True if vrf["evpnMulticast"]["enabled"] == "Yes" else False
                              tenant_data_model["vrfs"][vrf_name]["evpn_l3_multicast"] = {
                                  "enabled": l3_mcast_enabled
                              }

                          # pim rps
                          # Check to see if l3 evpn multicast is enabled
                          if tenant.get('evpnMulticast') is not None and tenant['evpnMulticast'].get('l3Multicast') is not None:
                              if tenant['evpnMulticast']['l3Multicast'].get("enabled", "") == "Yes" and vrf.get("evpnMulticast", {}).get("enabled", "").strip() != "No":
                                  l3_mcast_inputs = vrf['evpnMulticast']

                                  if l3_mcast_inputs.get('evpnPeg') and device_matches_resolver_query(l3_mcast_inputs['evpnPeg'], device_id):
                                      evpn_peg = {
                                          "nodes": [device_id]
                                      }
                                      if l3_mcast_inputs['evpnPeg'].resolve(device=device_id).get("transit", "") != "":
                                          evpn_peg["transit"] = True if l3_mcast_inputs['evpnPeg'].resolve(device=device_id)["transit"] == "Yes" else False
                                      tenant_data_model["vrfs"][vrf_name]["evpn_l3_multicast"]["evpn_peg"] = [evpn_peg]
                                  rp_groups = []
                                  for rp_group in l3_mcast_inputs.get("pimRpAddresses", []):
                                      if len(rp_group.get("rpIpAddresses", [])) > 0:
                                          rp_group_info = {
                                              "rps": rp_group["rpIpAddresses"]
                                          }
                                          if len(rp_group.get("groupAddresses", [])) > 0:
                                              rp_group_info["groups"] = rp_group["groupAddresses"]
                                          rp_groups.append(rp_group_info)
                                  if len(rp_groups) > 0:
                                      tenant_data_model["vrfs"][vrf_name]["pim_rp_addresses"] = rp_groups

                          # route-distinguisher
                          if vrf.get('overrideVariables') and vrf['overrideVariables'].get('routeDistinguisher').strip("") != "":
                              tenant_data_model["vrfs"][vrf_name]['route_distinguisher'] = vrf['overrideVariables']['routeDistinguisher']
                          else:
                              tenant_data_model["vrfs"][vrf_name]['route_distinguisher'] = vrf_attribute_formats['vrfRouteDistinguisherFormat']
                          # route-target
                          if vrf.get('overrideVariables') and vrf['overrideVariables'].get('routeTarget').strip("") != "":
                              tenant_data_model["vrfs"][vrf_name]['route_target'] = vrf['overrideVariables']['routeTarget']
                          else:
                              tenant_data_model["vrfs"][vrf_name]['route_target'] = vrf_attribute_formats['vrfRouteTargetFormat']

                  # Create dictionary for vlans (used for getting vni for VLANs in VLAN Aware Bundles)
                  vlan_vnis = {}
                  for vlan in vlans_in_tenant:
                      if not vlan:
                          continue
                      vlan_id = int(vlan["vlanId"])
                      # Create entry for VLAN's VNI if one exists
                      if vlan["vxlan"]:
                          if vlan.get('overrideVariables') and vlan['overrideVariables'].get('vni'):
                              vni = vlan['overrideVariables'].get('vni')
                          else:
                              vni = int(tenant_data_model["mac_vrf_vni_base"]) + int(vlan_id)
                      else:
                          vni = 0
                      vlan_vnis[vlan_id] = vni

                      # parse vlan info
                      if switch_facts["network_services_l2"] is True:
                          # If this is an L3 vlan
                          if vlan['l3OrL2']:
                              svi = {
                                  "description": None,
                                  "ip_helpers": {},
                                  "nodes": {},
                                  "vxlan": vlan["vxlan"]
                              }
                              # name
                              svi["name"] = vlan["name"] if vlan["name"].strip() != "" else None
                              # vrf
                              if vlan.get("vrf", "") == "":
                                  vrf_name =  "default"
                              else:
                                  vrf_name = vlan["vrf"]
                              # enable vlan
                              svi['enabled'] = True
                              if vlan['vxlan']:
                                  if vlan.get('overrideVariables') and vlan['overrideVariables'].get('vni'):
                                      svi['vni'] = vlan['overrideVariables'].get('vni')
                                  else:
                                      svi['vni'] = int(tenant_data_model["mac_vrf_vni_base"]) + int(vlan_id)
                                  # route-distinguisher
                                  if vlan.get('overrideVariables') and vlan['overrideVariables'].get('routeDistinguisher').strip("") != "":
                                      svi['route_distinguisher'] = vlan['overrideVariables']['routeDistinguisher']
                                  else:
                                      svi['route_distinguisher'] = vlan_based_mac_vrf_attribute_formats['macVrfRouteDistinguisherFormat']
                                  # route-target
                                  if vlan.get('overrideVariables') and vlan['overrideVariables'].get('routeTarget').strip("") != "":
                                      svi['route_target'] = vlan['overrideVariables']['routeTarget']
                                  else:
                                      svi['route_target'] = vlan_based_mac_vrf_attribute_formats['macVrfRouteTargetFormat']

                              # SVI IP address
                              # ip virtual-router address type config
                              if not vlan['sviIpAddresses'].get('virtualAddressConfigType'):
                                  # Get virtual ip address
                                  if vlan['vxlan']:
                                      # get virtual ip from general SVI IP address group input
                                      svi_vip = vlan['sviIpAddresses'].get('sviVirtualIpAddress')
                                  else:
                                      # get virtual ip from node resolver SVI IP address group input
                                      if vlan['nodes'].resolve(device=device_id)['sviIpInfo']['virtualIpAddress'].strip() != "":
                                          svi_vip = vlan['nodes'].resolve(device=device_id)['sviIpInfo']['virtualIpAddress']
                                      else:
                                          svi_vip = None
                                  # Get real ip address from node resolver
                                  svi_ip = vlan['nodes'].resolve(device=device_id)['sviIpInfo']['ipAddress'].strip()
                                  if not svi_ip:
                                      # Get real ip address from general SVI IP address group input
                                      if svi_vip and "/" in svi_vip:
                                          if vlan['sviIpAddresses'].get('primarySwitchSviIpAddress', '').strip():
                                              if switch_facts.get('mlag_role') and switch_facts['mlag_role'] == "secondary":
                                                  svi_ip = vlan['sviIpAddresses']['secondarySwitchSviIpAddress'] if vlan['sviIpAddresses'].get('secondarySwitchSviIpAddress', '').strip() else None
                                              else:
                                                  svi_ip = vlan['sviIpAddresses']['primarySwitchSviIpAddress']
                                          else:
                                              svi_vip_network = ipaddress.ip_interface(svi_vip).network
                                              if not vlan['sviIpAddresses'].get('primarySwitchSviIpAddress', '').strip():
                                                  ctx.warning(f"Automatically generating IP address for VLAN {vlan} interface based on Virtual IP address input for VLAN {vlan} in tenant {tenant['name']}")

                                              first_host = list(svi_vip_network.hosts())[0]
                                              last_host = list(svi_vip_network.hosts())[-1]
                                              if str(first_host) == svi_vip.split("/")[0]:
                                                  position = "start"
                                              elif str(last_host) == svi_vip.split("/")[0]:
                                                  position = "end"
                                              else:
                                                  assert False, f"Error: {vlan}'s virtual IP address must be either the " \
                                                                "first or last host address in the subnet if 'ip virtual-router address'" \
                                                                " config type is set"
                                              if switch_facts.get('mlag_role') and switch_facts['mlag_role'] == "secondary":
                                                  # take higher host address closest to vip
                                                  if position == "start":
                                                      svi_ip = list(svi_vip_network.hosts())[2]
                                                  else:
                                                      svi_ip = list(svi_vip_network.hosts())[-2]
                                              else:
                                                  # take lower host address closest to vip
                                                  if position == "start":
                                                      svi_ip = list(svi_vip_network.hosts())[1]
                                                  else:
                                                      svi_ip = list(svi_vip_network.hosts())[-3]
                                              # format ips
                                              svi_ip = f"{svi_ip}/{svi_vip_network.prefixlen}"
                                              svi_vip = svi_vip.split("/")[0]
                                      else:
                                          if switch_facts.get('mlag_role') and switch_facts['mlag_role'] == "secondary":
                                              svi_ip = vlan['sviIpAddresses']['secondarySwitchSviIpAddress'] if vlan['sviIpAddresses'].get('secondarySwitchSviIpAddress', '').strip() != "" else None
                                          else:
                                              svi_ip = vlan['sviIpAddresses']['primarySwitchSviIpAddress']
                                  # Set svi vip and ip
                                  if svi_vip:
                                      svi['ip_virtual_router_addresses'] = [svi_vip]
                                  if svi_ip:
                                      svi['ip_address'] = svi_ip

                              # ip address virtual type config
                              else:
                                  svi_vip = vlan['sviIpAddresses'].get('sviVirtualIpAddress')
                                  if svi_vip:
                                      svi["ip_address_virtual"] = svi_vip

                              # ip helper info
                              if len(vlan['dhcpServerDetails']) > 0:
                                  svi['ip_helpers'] = {}
                                  for dhcp_info in vlan['dhcpServerDetails']:
                                      if dhcp_info.get('dhcpServer') and dhcp_info['dhcpServer'].strip() != "":
                                          svi['ip_helpers'][dhcp_info['dhcpServer']] = {}
                                      if dhcp_info.get('sourceInterface') and dhcp_info['sourceInterface'].strip() != "":
                                          # set source interface associated with vrf
                                          svi['ip_helpers'][dhcp_info['dhcpServer']]['source_interface'] = dhcp_info['sourceInterface']

                              # mtu
                              svi['mtu'] = vlan['mtu']
                              # normalize arp
                              if vlan.get('arp'):
                                  svi['arp'] = {}
                                  if vlan['arp'].get('arpAgingTimeout'):
                                      svi['arp']['aging_timeout'] = vlan['arp']['arpAgingTimeout']

                              # evpn multicast
                              if vlan.get("evpnMulticast"):
                                  if vlan["evpnMulticast"].get("l3Enabled", "").strip():
                                      l3_mcast_enabled = True if vlan["evpnMulticast"]["l3Enabled"] == "Yes" else False
                                      svi["evpn_l3_multicast"] = {
                                          "enabled": l3_mcast_enabled
                                      }

                              # Add SVI's EOS CLI
                              svi['eos_cli'] = vlan['eosCli']

                              tenant_data_model["vrfs"][vrf_name]['svis'][vlan_id] = svi

                          else:
                              l2vlan = {
                                  "vxlan": vlan["vxlan"]
                              }
                              # name
                              l2vlan["name"] = vlan["name"] if vlan["name"].strip() != "" else None
                              if vlan["vxlan"]:
                                  if vlan.get('overrideVariables') and vlan['overrideVariables'].get('vni'):
                                      l2vlan['vni'] = vlan['overrideVariables'].get('vni')
                                  else:
                                      l2vlan['vni'] = int(tenant_data_model["mac_vrf_vni_base"]) + int(vlan_id)

                                  # route-distinguisher
                                  if vlan.get('overrideVariables') and vlan['overrideVariables'].get('routeDistinguisher').strip("") != "":
                                      l2vlan['route_distinguisher'] = vlan['overrideVariables']['routeDistinguisher']
                                  else:
                                      l2vlan['route_distinguisher'] = vlan_based_mac_vrf_attribute_formats['macVrfRouteDistinguisherFormat']
                                  # route-target
                                  if vlan.get('overrideVariables') and vlan['overrideVariables'].get('routeTarget').strip("") != "":
                                      l2vlan['route_target'] = vlan['overrideVariables']['routeTarget']
                                  else:
                                      l2vlan['route_target'] = vlan_based_mac_vrf_attribute_formats['macVrfRouteTargetFormat']

                              # evpn multicast
                              if vlan.get("evpnMulticast"):
                                  if vlan["evpnMulticast"].get("l2Enabled", "").strip():
                                      l2_mcast_enabled = True if vlan["evpnMulticast"]["l2Enabled"] == "Yes" else False
                                      l2vlan["evpn_l2_multicast"] = {
                                          "enabled": l2_mcast_enabled
                                      }

                              # etree
                              if vlan['eTreeDetails'].get('etreeEnable'):
                                  l2vlan['etree_leaf_export_rt_offset'] = vlan['eTreeDetails']['leafExportRouteTargetOffset']
                                  if vlan['eTreeRootSwitches'].resolve(device=device_id)['role'] == 'Root':
                                      l2vlan['etree_role'] = 'root'
                                  else:
                                      l2vlan['etree_role'] = 'leaf'

                              tenant_data_model["l2vlans"][vlan_id] = l2vlan


                  for vlan_aware_bundle in vlan_aware_bundles_in_tenant:
                      if not vlan_aware_bundle:
                          continue
                      bundle_name = vlan_aware_bundle['name']
                      bundle = {}
                      vlan_range = string_to_list(vlan_aware_bundle['vlanRange'])
                      # first and last vlan
                      bundle["first_vlan"] = vlan_range[0]
                      bundle["last_vlan"] = vlan_range[-1]
                      # first and last vni
                      bundle["first_vni"] = vlan_vnis.get(vlan_range[0], f"{int(tenant_data_model['mac_vrf_vni_base']) + int(vlan_range[0])}")
                      bundle["last_vni"] = vlan_vnis.get(vlan_range[-1], f"{int(tenant_data_model['mac_vrf_vni_base']) + int(vlan_range[-1])}")
                      # set compressed vlan range
                      bundle["vlan_range"] = list_compress(vlan_range)

                      # route-distinguisher
                      if vlan_aware_bundle.get('overrideVariables') and vlan_aware_bundle['overrideVariables'].get('routeDistinguisher').strip("") != "":
                          bundle['route_distinguisher'] = vlan_aware_bundle['overrideVariables']['routeDistinguisher']
                      else:
                          bundle['route_distinguisher'] = vlan_bundle_mac_vrf_attribute_formats['macVrfRouteDistinguisherFormat']
                      # route-target
                      if vlan_aware_bundle.get('overrideVariables') and vlan_aware_bundle['overrideVariables'].get('routeTarget').strip("") != "":
                          bundle['route_target'] = vlan_aware_bundle['overrideVariables']['routeTarget']
                      else:
                          bundle['route_target'] = vlan_bundle_mac_vrf_attribute_formats['macVrfRouteTargetFormat']


                      tenant_data_model['vlan_aware_bundles'][bundle_name] = bundle

                  tenants_data_model[tenant_name] = tenant_data_model

              switch_facts["all_tenants"] = tenants_data_model
              return switch_facts


          def get_neighbors(switch_facts):
              switch_facts['interfaces'] = get_interfaces_info(switch_facts)
              switch_facts["neighbor_ids"] = []
              for iface in switch_facts['interfaces'].values():
                  if iface["neighborId"] not in switch_facts["neighbor_ids"]:
                      switch_facts["neighbor_ids"].append(iface["neighborId"])

              return switch_facts


          workspace_id = ctx.studio.workspaceId
          my_device = ctx.getDevice()
          my_device_id = my_device.id

          if not tenants or not evpnGatewayVteps:
              ctx.info(f"No Tenants or Gateways input")
              return  # type: ignore

          config = {}

          # Pre-populate dictionaries used for getting switch facts
          node_id_dict = populate_single_value_dict(workspace_id, 'NodeId')
          network_services_dict = populate_multi_value_dict(workspace_id, 'NetworkServices')
          vtep_dict = populate_single_value_dict(workspace_id, 'Vtep')
          vtep_ip_dict = populate_single_value_dict(workspace_id, 'VtepIp')
          bgp_as_dict = populate_single_value_dict(workspace_id, 'router_bgp.as')
          router_id_dict = populate_single_value_dict(workspace_id, 'router_bgp.router_id')
          mlag_peer_link_dict = populate_single_value_dict(workspace_id, 'mlag_configuration.peer_link')
          role_dict = populate_multi_value_dict(workspace_id, 'Role')
          # Not necessary tags but good to have
          dc_dict = populate_single_value_dict(workspace_id, 'DC')
          pod_dict = populate_single_value_dict(workspace_id, 'DC-Pod')
          campus_dict = populate_single_value_dict(workspace_id, 'Campus')
          site_dict = populate_single_value_dict(workspace_id, 'Site')

          # Update advanced settings
          set_fabric_variables()

          # Get basics
          my_switch_facts = get_switch_basics_from_tags(my_device_id)

          # Get neighbors
          my_switch_facts = get_neighbors(my_switch_facts)
          ctx.info(f"{my_switch_facts['hostname']} neighbors: {my_switch_facts['neighbor_ids']}")

          # Get basics for all my neighbors
          my_neighbors_switch_facts = {}
          for switch_id in my_switch_facts["neighbor_ids"]:
               neighbor_switch_facts = get_switch_basics_from_tags(switch_id)
               my_neighbors_switch_facts[switch_id] = get_neighbors(neighbor_switch_facts)

          # Add my_switch_facts to neighbors
          my_neighbors_switch_facts[my_switch_facts['serial_number']] = my_switch_facts
          my_switch_facts = set_switch_facts(my_switch_facts)
          ctx.info(f"my_switch_facts: {my_switch_facts}")

          check_config_parameters(my_switch_facts)

          vlan_based_mac_vrf_attribute_formats = vlanBasedMacVrfAttributeFormats
          vlan_bundle_mac_vrf_attribute_formats = vlanBundleMacVrfAttributeFormats
          vrf_attribute_formats = vrfAttributeFormats

          my_switch_facts = get_tenants(my_switch_facts, tenants)

          # Check for duplicate VNIs
          check_vni_overlap(my_switch_facts['all_tenants'])

          gateway_switch_facts = None
          if len(my_switch_facts.get('gateway_switches', [])) > 0:
              gateway_switch_facts = get_switch_basics_from_tags(my_switch_facts['gateway_switches'][0])
              gateway_switch_facts = get_network_services_applied_to_switch(gateway_switch_facts, tenants)

          if gateway_switch_facts is None:
              return

          my_switch_facts['tenants'] = gateway_switch_facts['tenants']
          my_switch_facts['vlans'] = gateway_switch_facts['vlans']

          if len(my_switch_facts['tenants'].keys()) > 0 or len(my_switch_facts.get('evpn_gateway_remote_peers', [])) > 0:
              my_config = {
                  "vrfs": {},
                  "vlans": {},
                  "vlan_interfaces": {},
                  "port_channel_interfaces": {},
                  "ethernet_interfaces": {},
                  "loopback_interfaces": {},
                  "virtual_source_nat_vrfs": {},
                  "static_routes": [],
                  "route_maps": {},
                  "router_bgp": {
                      "peer_groups": {},
                      "neighbors": {}
                  },
                  "router_multicast": {
                      "vrfs": []
                  },
                  "router_pim_sparse_mode": {
                      "vrfs": []
                  }
              }
              my_config = set_base_config(my_config, my_switch_facts)
              my_config = set_overlay_config(my_config, my_switch_facts)
              my_config = set_network_services_config(my_config, my_switch_facts)
              my_config = clean_config(my_config)
          else:
              my_config = {}

          config = my_config
          %>
          ## eos - ip dhcp relay
          % if config.get("ip_dhcp_relay"):
          %     if config["ip_dhcp_relay"].get("information_option"):
          ip dhcp relay information option
          %     endif
          !
          % endif
          ## eos - ip dhcp snooping
          %if config.get("ip_dhcp_snooping"):
          ip dhcp snooping
          !
          %   if config["ip_dhcp_snooping"].get("information_option"):
          ip dhcp snooping information option
          %   endif
          %   if config["ip_dhcp_snooping"].get("vlans"):
          %       for vlan in config["ip_dhcp_snooping"]["vlans"]:
          ip dhcp snooping vlan ${vlan}
          %       endfor
          %   endif
          !
          %endif
          ## eos - IP IGMP Snooping
          % if config.get("ip_igmp_snooping"):
          %    if not config["ip_igmp_snooping"].get("globally_enabled"):
          no ip igmp snooping
          %    elif config["ip_igmp_snooping"].get("vlans"):
          %      for vlan in natural_sort(config["ip_igmp_snooping"]["vlans"], sort_key="id"):
          %          if not vlan.get("enabled"):
          no ip igmp snooping vlan ${ vlan['id'] }
          %          elif vlan.get("enabled", False) is True:
          ip igmp snooping vlan ${ vlan['id'] }
          %          endif
          %          if vlan.get("querier"):
          %              if vlan["querier"].get("enabled", False) is True:
          ip igmp snooping vlan ${ vlan["id"] } querier
          %              elif vlan["querier"].get("enabled", True) is False:
          no ip igmp snooping vlan ${ vlan["id"] } querier
          %              endif
          %              if vlan["querier"].get("address"):
          ip igmp snooping vlan ${ vlan["id"] } querier address ${ vlan["querier"]["address"] }
          %              endif
          %              if vlan["querier"].get("query_interval"):
          ip igmp snooping vlan ${ vlan["id"] } querier query-interval ${ vlan["querier"]["query_interval"] }
          %              endif
          %              if vlan["querier"].get("max_response_time"):
          ip igmp snooping vlan ${ vlan["id"] } querier max-response-time ${ vlan["querier"]["max_response_time"] }
          %              endif
          %              if vlan["querier"].get("last_member_query_interval"):
          ip igmp snooping vlan ${ vlan["id"] } querier last-member-query-interval ${ vlan["querier"]["last_member_query_interval"] }
          %              endif
          %              if vlan["querier"].get("last_member_query_count"):
          ip igmp snooping vlan ${ vlan["id"] } querier last-member-query-count ${ vlan["querier"]["last_member_query_count"] }
          %              endif
          %              if vlan["querier"].get("startup_query_interval"):
          ip igmp snooping vlan ${ vlan["id"] } querier startup-query-interval ${ vlan["querier"]["startup_query_interval"] }
          %              endif
          %              if vlan["querier"].get("startup_query_count"):
          ip igmp snooping vlan ${ vlan["id"] } querier startup-query-count ${ vlan["querier"]["startup_query_count"] }
          %              endif
          %              if vlan["querier"].get("version"):
          ip igmp snooping vlan ${ vlan["id"] } querier version ${ vlan["querier"]["version"] }
          %              endif
          %          endif
          %          if vlan.get("max_groups"):
          ip igmp snooping vlan ${ vlan["id"] } max-groups ${ vlan["max_groups"] }
          %          endif
          %          if vlan.get("fast_leave", False) is True:
          ip igmp snooping vlan ${ vlan["id"] } fast-leave
          %          elif vlan.get("fast_leave", True) is False:
          no ip igmp snooping vlan ${ vlan["id"] } fast-leave
          %          endif
          !
          %      endfor %}
          !
          %    endif
          %endif
          ## eos - VLANs
          %if config.get("vlans") is not None:
          %     for vlan in natural_sort(config.get("vlans")):
          vlan ${ vlan }
          %          if config.get("vlans")[vlan].get("name") is not None:
             name ${ config.get("vlans")[vlan].get("name") }
          %          endif
          %          if config.get("vlans")[vlan].get("state") is not None:
             state ${ config.get("vlans")[vlan].get("state") }
          %          endif
          %          if config.get("vlans")[vlan].get("trunk_groups") is not None:
          %               for trunk_group in config.get("vlans")[vlan].get("trunk_groups"):
             trunk group ${ trunk_group }
          %               endfor
          %          endif
          %          if config["vlans"][vlan].get("etree") is not None and config["vlans"][vlan]["etree"]["role"] == "leaf":
             e-tree role ${ config["vlans"][vlan]["etree"]["role"] }
          %          endif
          !
          %    endfor %}
          %endif
          ## vrfs
          % if config.get("vrfs") is not None:
          %   for vrf in natural_sort(config["vrfs"].keys()):
          vrf instance ${ vrf }
          %     if config["vrfs"][vrf].get("description"):
             description ${ config["vrfs"][vrf]["description"] }
          %     endif
          !
          %   endfor
          ## eos- Port-Channel Interfaces
          % if config.get("port_channel_interfaces") is not None:
          %   for port_channel_interface in natural_sort(config["port_channel_interfaces"].keys()):
          interface ${ port_channel_interface }
          %     if config["port_channel_interfaces"][port_channel_interface].get("description") is not None:
             description ${ config["port_channel_interfaces"][port_channel_interface]["description"] }
          %     endif
          %     if config["port_channel_interfaces"][port_channel_interface].get("shutdown") == True:
             shutdown
          %     elif config["port_channel_interfaces"][port_channel_interface].get("shutdown") == False:
             no shutdown
          %     endif
          %     if config["port_channel_interfaces"][port_channel_interface].get("mtu") is not None:
             mtu ${ config["port_channel_interfaces"][port_channel_interface]["mtu"] }
          %     endif
          %     if config["port_channel_interfaces"][port_channel_interface].get("type") is not None and config["port_channel_interfaces"][port_channel_interface].get("type") == "routed":
             no switchport
          %     else:
             switchport
          %     endif
          %     if config["port_channel_interfaces"][port_channel_interface].get("mode") is not None and config["port_channel_interfaces"][port_channel_interface].get("mode") == "access":
             switchport access vlan ${ config["port_channel_interfaces"][port_channel_interface]["vlans"] }
          %     endif %}
          %     if config["port_channel_interfaces"][port_channel_interface].get("mode") is not None and config["port_channel_interfaces"][port_channel_interface].get("mode") == "trunk":
             switchport mode ${ config["port_channel_interfaces"][port_channel_interface]["mode"] }
          %     endif
          %     if config["port_channel_interfaces"][port_channel_interface].get("trunk_groups") is not None:
          %       for trunk_group in config["port_channel_interfaces"][port_channel_interface]["trunk_groups"]:
             switchport trunk group ${ trunk_group }
          %       endfor
          %     endif
          !
          %   endfor
          % endif
          ## eos - Ethernet Interfaces
          %if config.get("ethernet_interfaces") is not None:
          %for ethernet_interface in natural_sort(config["ethernet_interfaces"].keys()):
          interface ${ethernet_interface }
          %     if config["ethernet_interfaces"][ethernet_interface].get("description") is not None:
             description ${config["ethernet_interfaces"][ethernet_interface]["description"]}
          %     endif
          %     if config["ethernet_interfaces"][ethernet_interface].get("shutdown") in [True]:
             shutdown
          %     elif config["ethernet_interfaces"][ethernet_interface].get("shutdown") in [False]:
             no shutdown
          %     endif
          %     if config["ethernet_interfaces"][ethernet_interface].get("channel_group") is not None:
             channel-group ${ config["ethernet_interfaces"][ethernet_interface]["channel_group"]["id"] } mode ${ config["ethernet_interfaces"][ethernet_interface]["channel_group"]["mode"] }
          %     else:
          %         if config["ethernet_interfaces"][ethernet_interface].get("mtu") is not None:
             mtu ${ config["ethernet_interfaces"][ethernet_interface]["mtu"] }
          %         endif
          %         if config["ethernet_interfaces"][ethernet_interface].get("type") is not None and config["ethernet_interfaces"][ethernet_interface].get("type") == "routed":
             no switchport
          %         elif config["ethernet_interfaces"][ethernet_interface].get("type") is not None and config["ethernet_interfaces"][ethernet_interface]["type"] == "l3dot1q" and config["ethernet_interfaces"][ethernet_interface].get("encapsulation_dot1q_vlan"):
             encapsulation dot1q vlan ${ config["ethernet_interfaces"][ethernet_interface]["encapsulation_dot1q_vlan"] }
          %         else:
             switchport
          %         endif
          %         if config["ethernet_interfaces"][ethernet_interface].get("mode") is not None and config["ethernet_interfaces"][ethernet_interface].get("mode") == "access":
          %             if config["ethernet_interfaces"][ethernet_interface].get("vlans") is not None:
             switchport access vlan ${ config["ethernet_interfaces"][ethernet_interface].get("vlans") }
          %             endif
          %         endif
          %         if config["ethernet_interfaces"][ethernet_interface].get("mode") is not None and config["ethernet_interfaces"][ethernet_interface].get("mode") == "trunk":
          %             if config["ethernet_interfaces"][ethernet_interface].get("vlans") is not None:
             switchport trunk allowed vlan ${ config["ethernet_interfaces"][ethernet_interface].get("vlans") }
          %             endif
          %             if config["ethernet_interfaces"][ethernet_interface].get("native_vlan") is not None:
             switchport trunk native vlan ${ config["ethernet_interfaces"][ethernet_interface].get("native_vlan") }
          %             endif
          %         endif
          %         if config["ethernet_interfaces"][ethernet_interface].get("mode") is not None:
             switchport mode ${ config["ethernet_interfaces"][ethernet_interface].get("mode") }
          %         endif
          %         if config["ethernet_interfaces"][ethernet_interface].get("trunk_groups") is not None:
          %             for trunk_group in config["ethernet_interfaces"][ethernet_interface].get("trunk_groups"):
             switchport trunk group ${ trunk_group }
          %             endfor
          %         endif
          %         if config["ethernet_interfaces"][ethernet_interface].get("vrf") is not None:
             vrf ${ config["ethernet_interfaces"][ethernet_interface].get("vrf") }
          %         endif
          %         if config["ethernet_interfaces"][ethernet_interface].get("ip_address") is not None:
             ip address ${ config["ethernet_interfaces"][ethernet_interface].get("ip_address") }
          %             if config["ethernet_interfaces"][ethernet_interface].get("ip_address_secondaries") is not None:
          %                 for ip_address_secondary in config["ethernet_interfaces"][ethernet_interface].get("ip_address_secondaries"):
             ip address ${ ip_address_secondary } secondary
          %                 endfor
          %             endif
          %         endif
          %         if config["ethernet_interfaces"][ethernet_interface].get("ospf_network_point_to_point"):
             ip ospf network point-to-point
          %         endif
          %         if config["ethernet_interfaces"][ethernet_interface].get("ospf_area"):
             ip ospf area ${ config["ethernet_interfaces"][ethernet_interface]["ospf_area"] }
          %         endif
          %     endif
          %         if config["ethernet_interfaces"][ethernet_interface].get("pim"):
          %           if config["ethernet_interfaces"][ethernet_interface]["pim"]["ipv4"].get("sparse_mode"):
             pim ipv4 sparse-mode
          %           endif
          %         endif
          %    if config["ethernet_interfaces"][ethernet_interface].get("eos_cli"):
          %       for statement in config["ethernet_interfaces"][ethernet_interface]["eos_cli"]:
             ${statement}
          %       endfor
          %    endif
          !
          %endfor
          %endif
          ## eos - Loopback Interfaces
          %if config.get("loopback_interfaces") is not None:
          %   for loopback_interface in natural_sort(config.get("loopback_interfaces").keys()):
          interface ${ loopback_interface }
          %       if config["loopback_interfaces"][loopback_interface].get("description") is not None:
             description ${ config["loopback_interfaces"][loopback_interface].get("description") }
          %       endif
          %       if config["loopback_interfaces"][loopback_interface].get("shutdown") is not None and config["loopback_interfaces"][loopback_interface].get("shutdown") == True:
             shutdown
          %       elif config["loopback_interfaces"][loopback_interface].get("shutdown") is not None and config["loopback_interfaces"][loopback_interface].get("shutdown") == False:
             no shutdown
          %       endif
          %       if config["loopback_interfaces"][loopback_interface].get("vrf") is not None:
             vrf ${ config["loopback_interfaces"][loopback_interface].get("vrf") }
          %       endif
          %       if config["loopback_interfaces"][loopback_interface].get("ip_address") is not None:
             ip address ${ config["loopback_interfaces"][loopback_interface].get("ip_address") }
          %           if config["loopback_interfaces"][loopback_interface].get("ip_address_secondaries") is not None:
          %               for ip_address_secondary in config["loopback_interfaces"][loopback_interface].get("ip_address_secondaries"):
             ip address ${ ip_address_secondary } secondary
          %               endfor
          %           endif
          %       endif
          !
          %   endfor
          %endif
          ## vlan-interfaces
          % if config.get("vlan_interfaces") is not None:
          %   for vlan_interface in natural_sort(config.get("vlan_interfaces").keys()):
          interface ${ vlan_interface }
          %     if config.get("vlan_interfaces")[vlan_interface].get("description") is not None:
             description ${ config.get("vlan_interfaces")[vlan_interface].get("description") }
          %     endif
          %     if config.get("vlan_interfaces")[vlan_interface].get("shutdown") == True:
             shutdown
          %     elif config.get("vlan_interfaces")[vlan_interface].get("shutdown") == False:
             no shutdown
          %     endif
          %     if config.get("vlan_interfaces")[vlan_interface].get("mtu") is not None:
             mtu ${ config.get("vlan_interfaces")[vlan_interface].get("mtu") }
          %     endif
          %     if config.get("vlan_interfaces")[vlan_interface].get("no_autostate") == True:
             no autostate
          %     endif
          %     if config.get("vlan_interfaces")[vlan_interface].get("vrf") is not None and config.get("vlan_interfaces")[vlan_interface]["vrf"] != "default":
             vrf ${ config.get("vlan_interfaces")[vlan_interface].get("vrf") }
          %     endif
          %     if config.get("vlan_interfaces")[vlan_interface].get("ip_address") is not None:
             ip address ${ config.get("vlan_interfaces")[vlan_interface].get("ip_address") }
          %         if config.get("vlan_interfaces")[vlan_interface].get("ip_address_secondaries") is not None:
          %             for ip_address_secondary in config["vlan_interfaces"][vlan_interface]["ip_address_secondaries"]:
             ip address ${ ip_address_secondary } secondary
          %             endfor
          %         endif
          %     endif
          %     if config["vlan_interfaces"][vlan_interface].get("ip_virtual_router_addresses") is not None:
          %         for ip_virtual_router_address in config["vlan_interfaces"][vlan_interface]["ip_virtual_router_addresses"]:
             ip virtual-router address ${ ip_virtual_router_address }
          %         endfor
          %     endif
          %     if config.get("vlan_interfaces")[vlan_interface].get("ip_address_virtual") is not None:
             ip address virtual ${ config.get("vlan_interfaces")[vlan_interface].get("ip_address_virtual") }
          %     endif
          %     if config.get("vlan_interfaces")[vlan_interface].get("ip_helpers") is not None:
          %       for ip_helper in config["vlan_interfaces"][vlan_interface].get("ip_helpers").keys():
          <%        ip_helper_cli = "ip helper-address " + ip_helper %>
          %         if config["vlan_interfaces"][vlan_interface]["ip_helpers"][ip_helper].get("vrf") is not None:
          <%            ip_helper_cli = ip_helper_cli + " vrf " + config.get("vlan_interfaces")[vlan_interface]["ip_helpers"][ip_helper].get("vrf") %>
          %         endif
          %         if config["vlan_interfaces"][vlan_interface]["ip_helpers"][ip_helper].get("source_interface") is not None:
          <%            ip_helper_cli = ip_helper_cli + " source-interface " + config.get("vlan_interfaces")[vlan_interface]["ip_helpers"][ip_helper].get("source_interface") %>
          %         endif %}
             ${ ip_helper_cli }
          %       endfor
          %    endif
          %    if config.get("vlan_interfaces")[vlan_interface].get("arp_aging_timeout") is not None:
             arp aging timeout ${ config.get("vlan_interfaces")[vlan_interface]["arp_aging_timeout"] }
          %    endif
          %     if config.get("vlan_interfaces")[vlan_interface].get("igmp"):
             ip igmp
          %       if config.get("vlan_interfaces")[vlan_interface]["igmp"].get("query_interval"):
             ip igmp query-interval ${config.get("vlan_interfaces")[vlan_interface]["igmp"]["query_interval"]}
          %       endif
          %     endif
          %    if config.get("vlan_interfaces")[vlan_interface].get("multicast"):
          %       if config.get("vlan_interfaces")[vlan_interface]["multicast"].get("ipv4"):
          %           if config.get("vlan_interfaces")[vlan_interface]["multicast"]["ipv4"].get("static"):
             multicast ipv4 static
          %           endif
          %       endif
          %    endif
          %    if config.get("vlan_interfaces")[vlan_interface].get("pim"):
          %       if config.get("vlan_interfaces")[vlan_interface]["pim"].get("ipv4"):
          %           if config["vlan_interfaces"][vlan_interface]["pim"]["ipv4"].get("sparse_mode"):
             pim ipv4 sparse-mode
          %           endif
          %           if config["vlan_interfaces"][vlan_interface]["pim"]["ipv4"].get("dr_priority"):
             pim ipv4 dr-priority ${ config["vlan_interfaces"][vlan_interface]["pim"]["ipv4"]["dr_priority"] }
          %           endif
          %           if config.get("vlan_interfaces")[vlan_interface]["pim"]["ipv4"].get("local_interface"):
             pim ipv4 local-interface ${config.get("vlan_interfaces")[vlan_interface]["pim"]["ipv4"]["local_interface"]}
          %           endif
          %       endif
          %    endif
          %    if config["vlan_interfaces"][vlan_interface].get("eos_cli"):
          %       for statement in config["vlan_interfaces"][vlan_interface]["eos_cli"]:
             ${statement}
          %       endfor
          %    endif
          !
          %   endfor
          % endif
          ## vxlan-interfaces
          % if config.get("vxlan_interface"):
          interface Vxlan1
          %     if config["vxlan_interface"]["Vxlan1"].get("source_interface"):
             vxlan source-interface ${ config["vxlan_interface"]["Vxlan1"]["source_interface"] }
          %     endif
          %     if config["vxlan_interface"]["Vxlan1"].get("vxlan"):
          %         if config["vxlan_interface"]["Vxlan1"]["vxlan"].get("virtual_router_encapsulation_mac_address"):
             vxlan virtual-router encapsulation mac-address ${ config["vxlan_interface"]["Vxlan1"]["vxlan"]["virtual_router_encapsulation_mac_address"] }
          %         endif
          %         if config["vxlan_interface"]["Vxlan1"].get("vxlan_udp_port"):
             vxlan udp-port ${ config["vxlan_interface"]["Vxlan1"]["vxlan_udp_port"] }
          %         endif
          %         if config["vxlan_interface"]["Vxlan1"]["vxlan"].get("vlans"):
          %             for vlan in natural_sort(config["vxlan_interface"]["Vxlan1"]["vxlan"]["vlans"].keys()):
             vxlan vlan ${ vlan } vni ${ config["vxlan_interface"]["Vxlan1"]["vxlan"]["vlans"][vlan]["vni"] }
          %               if config["vxlan_interface"]["Vxlan1"]["vxlan"]["vlans"][vlan].get("multicast_group"):
             vxlan vlan ${ vlan } multicast group ${config["vxlan_interface"]["Vxlan1"]["vxlan"]["vlans"][vlan]["multicast_group"]}
          %               endif
          %             endfor
          %         endif
          %         if config["vxlan_interface"]["Vxlan1"]["vxlan"].get("vrfs"):
          %             for vrf in natural_sort(config["vxlan_interface"]["Vxlan1"]["vxlan"]["vrfs"].keys()):
             vxlan vrf ${ vrf } vni ${ config["vxlan_interface"]["Vxlan1"]["vxlan"]["vrfs"][vrf]["vni"] }
          %               if config["vxlan_interface"]["Vxlan1"]["vxlan"]["vrfs"][vrf].get("multicast_group"):
             vxlan vrf ${ vrf } multicast group ${config["vxlan_interface"]["Vxlan1"]["vxlan"]["vrfs"][vrf]["multicast_group"]}
          %               endif
          %             endfor %}
          %         endif
          %     endif
          !
          % endif
          ## eos - IP Routing
          % if config.get("ip_routing") == True:
          ip routing
          !
          % elif config.get("ip_routing") == False:
          no ip routing
          !
          % endif
          %   for vrf in config.get("vrfs"):
          %       if config.get("vrfs")[vrf].get("ip_routing") is not None and config.get("vrfs")[vrf].get("ip_routing") == True  and vrf != 'default':
          ip routing vrf ${ vrf }
          %       elif config.get("vrfs")[vrf].get("ip_routing") is not None and config.get("vrfs")[vrf].get("ip_routing") == False  and vrf != 'default':
          no ip routing vrf ${ vrf }
          %       endif
          %   endfor
          !
          % endif
          ## static routes
          % if config.get("static_routes"):
          %     for static_route in config["static_routes"]:
          <%         static_route_cli = "ip route" %>
          %         if static_route.get("vrf") and static_route["vrf"] != 'default':
          <%             static_route_cli = static_route_cli + " vrf " + static_route["vrf"] %>
          %         endif
          %         if static_route.get("destination_address_prefix"):
          <%             static_route_cli = static_route_cli + " " + static_route["destination_address_prefix"] %>
          %         endif
          %         if static_route.get("interface"):
          <%             static_route_cli = static_route_cli + " " + static_route["interface"].upper() %>
          %         endif
          %         if static_route.get("gateway"):
          <%             static_route_cli = static_route_cli + " " + static_route["gateway"] %>
          %         endif
          %         if static_route.get("distance"):
          <%             static_route_cli = static_route_cli + " " + static_route["distance"] %>
          %         endif
          %         if static_route.get("tag"):
          <%             static_route_cli = static_route_cli + " tag " + static_route["tag"] %>
          %         endif
          %         if static_route.get("name"):
          <%             static_route_cli = static_route_cli + " name " + static_route["name"] %>
          %         endif
          %         if static_route.get("metric"):
          <%             static_route_cli = static_route_cli + " metric " + static_route["metric"] %>
          %         endif
          ${ static_route_cli }
          !
          %    endfor %}
          % endif
          ## virtual source nat
          % if config.get("virtual_source_nat_vrfs"):
          %     for vrf in natural_sort(config["virtual_source_nat_vrfs"].keys()):
          %         if config["virtual_source_nat_vrfs"][vrf].get("ip_address"):
          ip address virtual source-nat vrf ${ vrf } address ${ config["virtual_source_nat_vrfs"][vrf]["ip_address"] }
          %         endif
          %     endfor
          !
          % endif
          ## eos - Route Maps
          % if config.get("route_maps") is not None:
          %   for route_map in natural_sort(config["route_maps"].keys()):
          %       for sequence in config["route_maps"][route_map]["sequence_numbers"].keys():
          %           if config["route_maps"][route_map]["sequence_numbers"][sequence].get("type") is not None:
          route-map ${ route_map } ${ config["route_maps"][route_map]["sequence_numbers"][sequence]["type"] } ${ sequence }
          %               if config["route_maps"][route_map]["sequence_numbers"][sequence].get("description") is not None:
             description ${ config["route_maps"][route_map]["sequence_numbers"][sequence]["description"] }
          %               endif
          %               if config["route_maps"][route_map]["sequence_numbers"][sequence].get("match") is not None:
          %                   for match_rule in config["route_maps"][route_map]["sequence_numbers"][sequence]["match"]:
             match ${ match_rule }
          %                   endfor
          %               endif
          %               if config["route_maps"][route_map]["sequence_numbers"][sequence].get("set") is not None:
          %                   for set_rule in config["route_maps"][route_map]["sequence_numbers"][sequence]["set"]:
             set ${ set_rule }
          %                   endfor
          %               endif
          !
          %           endif
          %       endfor
          %   endfor
          % endif
          ## router-bgp
          % if config.get("router_bgp") is not None:
          % if config["router_bgp"].get("as") is not None:
          router bgp ${ config["router_bgp"]["as"] }
          %     if config["router_bgp"].get("router_id") is not None:
             router-id ${ config["router_bgp"]["router_id"] }
          %     endif
          %     if config["router_bgp"].get("bgp_defaults") is not None:
          %       for bgp_default in config["router_bgp"]["bgp_defaults"]:
             ${ bgp_default }
          %       endfor
          %     endif
          %     if config["router_bgp"].get("peer_groups") is not None:
          %       for peer_group in config["router_bgp"]["peer_groups"].keys():
          %         if config["router_bgp"]["peer_groups"][peer_group].get("bgp_listen_range_prefix") is not None and config["router_bgp"]["peer_groups"][peer_group].get("peer_filter") is not None:
             bgp listen range ${ config["router_bgp"]["peer_groups"][peer_group]["bgp_listen_range_prefix"] } peer-group ${ peer_group } peer-filter ${ config["router_bgp"]["peer_groups"][peer_group]["peer_filter"] }
          %         endif
          %       endfor
          %     for peer_group in config["router_bgp"]["peer_groups"].keys():
          %         if config["router_bgp"]["peer_groups"][peer_group].get("description") is not None:
             neighbor ${ peer_group } description ${ config["router_bgp"]["peer_groups"][peer_group]["description"] }
          %         endif
          %         if config["router_bgp"]["peer_groups"][peer_group].get("shutdown") == True:
             neighbor ${ peer_group } shutdown
          %         endif
             neighbor ${ peer_group } peer group
          %         if config["router_bgp"]["peer_groups"][peer_group].get("remote_as") is not None:
             neighbor ${ peer_group } remote-as ${ config["router_bgp"]["peer_groups"][peer_group]["remote_as"] }
          %         endif
          %         if config["router_bgp"]["peer_groups"][peer_group].get("local_as") is not None:
             neighbor ${ peer_group } local-as ${ config["router_bgp"]["peer_groups"][peer_group]["local_as"] } no-prepend replace-as
          %         endif
          %         if config["router_bgp"]["peer_groups"][peer_group].get("next_hop_self") == True:
             neighbor ${ peer_group } next-hop-self
          %         endif
          %         if config["router_bgp"]["peer_groups"][peer_group].get("next_hop_unchanged") == True:
             neighbor ${ peer_group } next-hop-unchanged
          %         endif
          %         if config["router_bgp"]["peer_groups"][peer_group].get("update_source") is not None:
             neighbor ${ peer_group } update-source ${ config["router_bgp"]["peer_groups"][peer_group]["update_source"] }
          %         endif
          %         if config["router_bgp"]["peer_groups"][peer_group].get("route_reflector_client") == True:
             neighbor ${ peer_group } route-reflector-client
          %         endif
          %         if config["router_bgp"]["peer_groups"][peer_group].get("bfd") == True:
             neighbor ${ peer_group } bfd
          %         endif
          %         if config["router_bgp"]["peer_groups"][peer_group].get("ebgp_multihop") is not None:
             neighbor ${ peer_group } ebgp-multihop ${ config["router_bgp"]["peer_groups"][peer_group]["ebgp_multihop"] }
          %         endif
          %         if config["router_bgp"]["peer_groups"][peer_group].get("password") is not None:
             neighbor ${ peer_group } password 7 ${ config["router_bgp"]["peer_groups"][peer_group]["password"] }
          %         endif
          %         if config["router_bgp"]["peer_groups"][peer_group].get("send_community") is not None and config["router_bgp"]["peer_groups"][peer_group]["send_community"] == "all":
             neighbor ${ peer_group } send-community
          %         elif config["router_bgp"]["peer_groups"][peer_group].get("send_community") is not None:
             neighbor ${ peer_group } send-community ${ config["router_bgp"]["peer_groups"][peer_group]["send_community"] }
          %         endif
          %         if config["router_bgp"]["peer_groups"][peer_group].get("maximum_routes") is not None:
          <%            max_routes_cli = f"neighbor {peer_group} maximum-routes {config['router_bgp']['peer_groups'][peer_group]['maximum_routes']}" %>
          %             if config["router_bgp"]["peer_groups"][peer_group].get("maximum_routes_warning_limit") is not None:
          <%                max_routes_cli += f" warning-limit {config['router_bgp']['peer_groups'][peer_group]['maximum_routes_warning_limit']}"  %>
          %             endif
             ${max_routes_cli}
          %         endif
          %         if config["router_bgp"]["peer_groups"][peer_group].get("weight") is not None:
             neighbor ${ peer_group } weight ${ config["router_bgp"]["peer_groups"][peer_group]["weight"] }
          %         endif
          %         if config["router_bgp"]["peer_groups"][peer_group].get("timers") is not None:
             neighbor ${ peer_group } timers ${ config["router_bgp"]["peer_groups"][peer_group]["timers"] }
          %         endif
          %         if config["router_bgp"]["peer_groups"][peer_group].get("route_map_in") is not None:
             neighbor ${ peer_group } route-map ${ config["router_bgp"]["peer_groups"][peer_group]["route_map_in"] } in
          %         endif
          %         if config["router_bgp"]["peer_groups"][peer_group].get("route_map_out") is not None:
             neighbor ${ peer_group } route-map ${ config["router_bgp"]["peer_groups"][peer_group]["route_map_out"] } out
          %         endif
          %       endfor
          %     endif
          %     if config["router_bgp"].get("neighbors") is not None:
          %       for neighbor in config["router_bgp"]["neighbors"].keys():
          %         if config["router_bgp"]["neighbors"][neighbor].get("peer_group") is not None:
             neighbor ${ neighbor } peer group ${ config["router_bgp"]["neighbors"][neighbor]["peer_group"] }
          %         endif
          %         if config["router_bgp"]["neighbors"][neighbor].get("remote_as") is not None:
             neighbor ${ neighbor } remote-as ${ config["router_bgp"]["neighbors"][neighbor]['remote_as'] }
          %         endif
          %         if config["router_bgp"]["neighbors"][neighbor].get("next_hop_self") == True:
             neighbor ${ neighbor } next-hop-self
          %         endif
          %         if config["router_bgp"]["neighbors"][neighbor].get("shutdown") == True:
             neighbor ${ neighbor } shutdown
          %         endif
          %         if config["router_bgp"]["neighbors"][neighbor].get("local_as") is not None:
             neighbor ${ neighbor } local-as ${ config["router_bgp"]["neighbors"][neighbor]["local_as"] } no-prepend replace-as
          %         endif
          %         if config["router_bgp"]["neighbors"][neighbor].get("description") is not None:
             neighbor ${ neighbor } description ${ config["router_bgp"]["neighbors"][neighbor]["description"] }
          %         endif
          %         if config["router_bgp"]["neighbors"][neighbor].get("update_source") is not None:
             neighbor ${ neighbor } update-source ${ config["router_bgp"]["neighbors"][neighbor]["update_source"] }
          %         endif
          %         if config["router_bgp"]["neighbors"][neighbor].get("bfd") == True:
             neighbor ${ neighbor } bfd
          %         endif
          %         if config["router_bgp"]["neighbors"][neighbor].get("password") is not None:
             neighbor ${ neighbor } password 7 ${ config["router_bgp"]["neighbors"][neighbor]["password"] }
          %         endif
          %         if config["router_bgp"]["neighbors"][neighbor].get("weight") is not None:
             neighbor ${ neighbor } weight ${ config["router_bgp"]["neighbors"][neighbor]["weight"] }
          %         endif
          %         if config["router_bgp"]["neighbors"][neighbor].get("timers") is not None:
             neighbor ${ neighbor } timers ${ config["router_bgp"]["neighbors"][neighbor]["timers"] }
          %         endif
          %         if config["router_bgp"]["neighbors"][neighbor].get("route_map_in") is not None:
             neighbor ${ neighbor } route-map ${ config["router_bgp"]["neighbors"][neighbor]["route_map_in"] } in
          %         endif
          %         if config["router_bgp"]["neighbors"][neighbor].get("route_map_out") is not None:
             neighbor ${ neighbor } route-map ${ config["router_bgp"]["neighbors"][neighbor]["route_map_out"] } out
          %         endif
          %       endfor
          %     endif
          ## {%     endfor %}
          %     if config["router_bgp"].get("redistribute_routes") is not None:
          %       for redistribute_route in config["router_bgp"]["redistribute_routes"].keys():
          <%         redistribute_route_cli = "redistribute " + redistribute_route %>
          %         if config["router_bgp"]["redistribute_routes"][redistribute_route].get("route_map") is not None:
          <%             redistribute_route_cli = redistribute_route_cli + " route-map " + config["router_bgp"]["redistribute_routes"][redistribute_route]["route_map"] %>
          %         endif
             ${ redistribute_route_cli }
          %       endfor
          %     endif
          ## L2VPNs - (vxlan) vlan based
          %     if config["router_bgp"].get("vlans") is not None:
          %       for vlan in natural_sort(config["router_bgp"]["vlans"]):
             !
             vlan ${ vlan }
          %         if config["router_bgp"]["vlans"][vlan].get("rd") is not None:
                rd ${ config["router_bgp"]["vlans"][vlan]["rd"] }
          %         endif
          %         if config["router_bgp"]["vlans"][vlan].get("rd_evpn_domain") is not None:
          %             if config["router_bgp"]["vlans"][vlan]["rd_evpn_domain"].get('domain') is not None and config["router_bgp"]["vlans"][vlan]["rd_evpn_domain"].get('rd') is not None:
                rd evpn domain ${ config["router_bgp"]["vlans"][vlan]["rd_evpn_domain"]["domain"] } ${ config["router_bgp"]["vlans"][vlan]["rd_evpn_domain"]["rd"] }
          %             endif
          %         endif
          %         if config["router_bgp"]["vlans"][vlan].get("route_targets") is not None and config["router_bgp"]["vlans"][vlan]["route_targets"].get("both") is not None:
          %             for route_target in config["router_bgp"]["vlans"][vlan]["route_targets"]["both"]:
                route-target both ${ route_target }
          %             endfor
          %         endif
          %         if config["router_bgp"]["vlans"][vlan].get("route_targets") is not None and config["router_bgp"]["vlans"][vlan]["route_targets"].get("import") is not None:
          %             for route_target in config["router_bgp"]["vlans"][vlan]["route_targets"]["import"]:
                route-target import ${ route_target }
          %             endfor
          %         endif
          %         if config["router_bgp"]["vlans"][vlan].get("route_targets") is not None and config["router_bgp"]["vlans"][vlan]["route_targets"].get("export") is not None:
          %             for route_target in config["router_bgp"]["vlans"][vlan]["route_targets"]["export"]:
                route-target export ${ route_target }
          %             endfor
          %         endif
          %         if config["router_bgp"]["vlans"][vlan].get("route_targets") is not None and config["router_bgp"]["vlans"][vlan]["route_targets"].get("import_evpn_domains") is not None:
          %             for route_target in config["router_bgp"]["vlans"][vlan]["route_targets"]["import_evpn_domains"]:
                route-target import evpn domain ${ route_target.get('domain') } ${ route_target.get('route_target') }
          %             endfor
          %         endif
          %         if config["router_bgp"]["vlans"][vlan].get("route_targets") is not None and config["router_bgp"]["vlans"][vlan]["route_targets"].get("export_evpn_domains") is not None:
          %             for route_target in config["router_bgp"]["vlans"][vlan]["route_targets"]["export_evpn_domains"]:
                route-target export evpn domain ${ route_target.get('domain') } ${ route_target.get('route_target') }
          %             endfor %}
          %        endif
          %         if config["router_bgp"]["vlans"][vlan].get("route_targets") is not None and config["router_bgp"]["vlans"][vlan]["route_targets"].get("import_export_evpn_domains") is not None:
          %             for route_target in config["router_bgp"]["vlans"][vlan]["route_targets"]["import_export_evpn_domains"]:
                route-target import export evpn domain ${ route_target.get('domain') } ${ route_target.get('route_target') }
          %             endfor %}
          %         endif
          %         if config["router_bgp"]["vlans"][vlan].get("redistribute_routes") is not None:
          %           for redistribute_route in config["router_bgp"]["vlans"][vlan]["redistribute_routes"]:
                redistribute ${ redistribute_route }
          %           endfor
          %         endif
          %       endfor
          ## vxlan vlan aware bundles
          %       if config["router_bgp"].get("vlan_aware_bundles") is not None:
          %         for vlan_aware_bundle in config["router_bgp"]["vlan_aware_bundles"].keys():
             !
             vlan-aware-bundle ${ vlan_aware_bundle }
          %         if  config["router_bgp"]["vlan_aware_bundles"][vlan_aware_bundle].get("rd") is not None:
                rd ${  config["router_bgp"]["vlan_aware_bundles"][vlan_aware_bundle]["rd"] }
          %         endif
          %         if config["router_bgp"]["vlan_aware_bundles"][vlan_aware_bundle].get("rd_evpn_domain") is not None:
          %             if config["router_bgp"]["vlan_aware_bundles"][vlan_aware_bundle]["rd_evpn_domain"].get('domain') is not None and config["router_bgp"]["vlan_aware_bundles"][vlan_aware_bundle]["rd_evpn_domain"].get('rd') is not None:
                rd evpn domain ${ config["router_bgp"]["vlan_aware_bundles"][vlan_aware_bundle]["rd_evpn_domain"]["domain"] } ${ config["router_bgp"]["vlan_aware_bundles"][vlan_aware_bundle]["rd_evpn_domain"]["rd"] }
          %             endif
          %         endif
          %         if config["router_bgp"]["vlan_aware_bundles"][vlan_aware_bundle].get("route_targets") is not None and config["router_bgp"]["vlan_aware_bundles"][vlan_aware_bundle]["route_targets"].get("both") is not None:
          %             for route_target in  config["router_bgp"]["vlan_aware_bundles"][vlan_aware_bundle]["route_targets"]["both"]:
                route-target both ${ route_target }
          %             endfor
          %         endif
          %         if config["router_bgp"]["vlan_aware_bundles"][vlan_aware_bundle].get("route_targets") is not None and config["router_bgp"]["vlan_aware_bundles"][vlan_aware_bundle]["route_targets"].get("import") is not None:
          %             for route_target in config["router_bgp"]["vlan_aware_bundles"][vlan_aware_bundle]["route_targets"]["import"]:
                route-target import ${ route_target }
          %             endfor
          %         endif
          %         if config["router_bgp"]["vlan_aware_bundles"][vlan_aware_bundle].get("route_targets") is not None and config["router_bgp"]["vlan_aware_bundles"][vlan_aware_bundle]["route_targets"].get("export") is not None:
          %             for route_target in  config["router_bgp"]["vlan_aware_bundles"][vlan_aware_bundle]["route_targets"]["export"]:
                route-target export ${ route_target }
          %             endfor
          %         endif
          %         if config["router_bgp"]["vlan_aware_bundles"][vlan_aware_bundle].get("route_targets") is not None and config["router_bgp"]["vlan_aware_bundles"][vlan_aware_bundle]["route_targets"].get("import_evpn_domains") is not None:
          %             for route_target in config["router_bgp"]["vlan_aware_bundles"][vlan_aware_bundle]["route_targets"]["import_evpn_domains"]:
                route-target import evpn domain ${ route_target.get('domain') } ${ route_target.get('route_target') }
          %             endfor
          %         endif
          %         if config["router_bgp"]["vlan_aware_bundles"][vlan_aware_bundle].get("route_targets") is not None and config["router_bgp"]["vlan_aware_bundles"][vlan_aware_bundle]["route_targets"].get("export_evpn_domains") is not None:
          %             for route_target in config["router_bgp"]["vlan_aware_bundles"][vlan_aware_bundle]["route_targets"]["export_evpn_domains"]:
                route-target export evpn domain ${ route_target.get('domain') } ${ route_target.get('route_target') }
          %             endfor %}
          %        endif
          %         if config["router_bgp"]["vlan_aware_bundles"][vlan_aware_bundle].get("route_targets") is not None and config["router_bgp"]["vlan_aware_bundles"][vlan_aware_bundle]["route_targets"].get("import_export_evpn_domains") is not None:
          %             for route_target in config["router_bgp"]["vlan_aware_bundles"][vlan_aware_bundle]["route_targets"]["import_export_evpn_domains"]:
                route-target import export evpn domain ${ route_target.get('domain') } ${ route_target.get('route_target') }
          %             endfor %}
          %         endif
          %         if config["router_bgp"]["vlan_aware_bundles"][vlan_aware_bundle].get("redistribute_routes") is not None:
          %           for redistribute_route in config["router_bgp"]["vlan_aware_bundles"][vlan_aware_bundle]["redistribute_routes"]:
                redistribute ${ redistribute_route }
          %           endfor %}
          %         endif
          %         if config["router_bgp"]["vlan_aware_bundles"][vlan_aware_bundle].get("vlan") is not None:
                vlan ${ config["router_bgp"]["vlan_aware_bundles"][vlan_aware_bundle]["vlan"] }
          %         endif
          %         endfor
          %       endif
          %     endif
          ## address families activation
          ## address family evpn activation ##
          %     if config["router_bgp"].get("address_family_evpn") is not None:
             !
             address-family evpn
          %         if config["router_bgp"]["address_family_evpn"].get("evpn_hostflap_detection") is not None and config["router_bgp"]["address_family_evpn"]["evpn_hostflap_detection"].get("enabled") == False:
                no host-flap detection
          %         else:
          %             if config["router_bgp"]["address_family_evpn"].get("evpn_hostflap_detection") is not None and config["router_bgp"]["address_family_evpn"]["evpn_hostflap_detection"].get("window") is not None:
                host-flap detection window ${ config["router_bgp"]["address_family_evpn"]["evpn_hostflap_detection"]["window"] }
          %             endif
          %             if config["router_bgp"]["address_family_evpn"].get("evpn_hostflap_detection") is not None and config["router_bgp"]["address_family_evpn"]["evpn_hostflap_detection"].get("threshold") is not None:
                host-flap detection threshold ${ config["router_bgp"]["address_family_evpn"]["evpn_hostflap_detection"]["threshold"] }
          %             endif
          %         endif
          %         if config["router_bgp"]["address_family_evpn"].get("domain_identifier") is not None:
                domain identifier ${ config["router_bgp"]["address_family_evpn"]["domain_identifier"] }
          %         endif
          %         if config["router_bgp"]["address_family_evpn"].get("peer_groups") is not None:
          %           for peer_group in config["router_bgp"]["address_family_evpn"]["peer_groups"].keys():
          %             if config["router_bgp"]["address_family_evpn"]["peer_groups"][peer_group].get("route_map_in") is not None:
                neighbor ${ peer_group } route-map ${ config["router_bgp"]["address_family_evpn"]["peer_groups"][peer_group]["route_map_in"] } in
          %             endif
          %             if config["router_bgp"]["address_family_evpn"]["peer_groups"][peer_group].get("route_map_out") is not None:
                neighbor ${ peer_group } route-map ${ config["router_bgp"]["address_family_evpn"]["peer_groups"][peer_group]["route_map_out"] } out
          %             endif
          %             if config["router_bgp"]["address_family_evpn"]["peer_groups"][peer_group].get("activate") == True:
                neighbor ${ peer_group } activate
          %             elif config["router_bgp"]["address_family_evpn"]["peer_groups"][peer_group].get("activate") == False:
                no neighbor ${ peer_group } activate
          %             endif
          %             if config["router_bgp"]["address_family_evpn"]["peer_groups"][peer_group].get('domain_remote'):
                neighbor ${ peer_group } domain remote
          %             endif
          %           endfor
          %           if config["router_bgp"]["address_family_evpn"].get('neighbor_default'):
          %               if config["router_bgp"]["address_family_evpn"]['neighbor_default'].get('next_hop_self_received_evpn_routes'):
          %                   if config["router_bgp"]["address_family_evpn"]['neighbor_default']['next_hop_self_received_evpn_routes'].get('enable'):
          <%                      evpn_neighbor_default_nhs_received_evpn_routes_cli = "neighbor default next-hop-self received-evpn-routes route-type ip-prefix" %>
          %                       if config["router_bgp"]["address_family_evpn"]['neighbor_default']['next_hop_self_received_evpn_routes'].get('inter_domain'):
          <%                          evpn_neighbor_default_nhs_received_evpn_routes_cli = evpn_neighbor_default_nhs_received_evpn_routes_cli + " inter-domain" %>
          %                       endif
                ${ evpn_neighbor_default_nhs_received_evpn_routes_cli }
          %                   endif
          %               endif
          %           endif
          %         endif
          %     endif
          ## address family ipv4 activation
          %     if config["router_bgp"].get("address_family_ipv4") is not None:
             !
             address-family ipv4
          %       if config["router_bgp"]["address_family_ipv4"].get("networks") is not None:
          %         for network in config["router_bgp"]["address_family_ipv4"]["networks"].keys():
          %             if config["router_bgp"]["address_family_ipv4"]["networks"][network].get("route_map") is not None:
                network ${ network } route-map ${ config["router_bgp"]["address_family_ipv4"]["networks"][network]["route_map"] }
          %             else:
                network ${ network }
          %             endif
          %         endfor
          %       endif
          %       if config["router_bgp"]["address_family_ipv4"].get("peer_groups") is not None:
          %           for peer_group in config["router_bgp"]["address_family_ipv4"]["peer_groups"].keys():
          %             if config["router_bgp"]["address_family_ipv4"]["peer_groups"][peer_group].get("route_map_in") is not None:
                neighbor ${ peer_group } route-map ${ config["router_bgp"]["address_family_ipv4"]["peer_groups"][peer_group]["route_map_in"] } in
          %             endif
          %             if config["router_bgp"]["address_family_ipv4"]["peer_groups"][peer_group].get("route_map_out") is not None:
                neighbor ${ peer_group } route-map ${ config["router_bgp"]["address_family_ipv4"]["peer_groups"][peer_group]["route_map_out"] } out
          %             endif
          %             if config["router_bgp"]["address_family_ipv4"]["peer_groups"][peer_group].get("prefix_list_in") is not None:
                neighbor ${ peer_group } prefix-list ${ config["router_bgp"]["address_family_ipv4"]["peer_groups"][peer_group]["prefix_list_in"] } in
          %             endif
          %             if config["router_bgp"]["address_family_ipv4"]["peer_groups"][peer_group].get("prefix_list_out") is not None:
                neighbor ${ peer_group } prefix-list ${ config["router_bgp"]["address_family_ipv4"]["peer_groups"][peer_group]["prefix_list_out"] } out
          %             endif
          %             if config["router_bgp"]["address_family_ipv4"]["peer_groups"][peer_group].get("activate") == True:
                neighbor ${ peer_group } activate
          %             elif config["router_bgp"]["address_family_ipv4"]["peer_groups"][peer_group].get("activate") == False:
                no neighbor ${ peer_group } activate
          %             endif
          %           endfor
          %       endif
          %       if config["router_bgp"]["address_family_ipv4"].get("neighbors") is not None:
          %           for neighbor in config["router_bgp"]["address_family_ipv4"]["neighbors"].keys():
          %             if config["router_bgp"]["address_family_ipv4"]["neighbors"][neighbor].get("route_map_in") is not None:
                neighbor ${ neighbor } route-map ${ config["router_bgp"]["address_family_ipv4"]["neighbors"][neighbor]["route_map_in"] } in
          %             endif
          %             if config["router_bgp"]["address_family_ipv4"]["neighbors"][neighbor].get("route_map_out") is not None:
                neighbor ${ neighbor } route-map ${ config["router_bgp"]["address_family_ipv4"]["neighbors"][neighbor]["route_map_out"] } out
          %             endif
          %             if config["router_bgp"]["address_family_ipv4"]["neighbors"][neighbor].get("prefix_list_in") is not None:
                neighbor ${ neighbor } prefix-list ${ config["router_bgp"]["address_family_ipv4"]["neighbors"][neighbor]["prefix_list_in"] } in
          %             endif
          %             if config["router_bgp"]["address_family_ipv4"]["neighbors"][neighbor].get("prefix_list_out") is not None:
                neighbor ${ neighbor } prefix-list ${ config["router_bgp"]["address_family_ipv4"]["neighbors"][neighbor]["prefix_list_out"] } out
          %             endif
          %             if config["router_bgp"]["address_family_ipv4"]["neighbors"][neighbor].get("default_originate") is not None:
          <%                 neighbor_default_originate_cli = "neighbor " + neighbor + " default-originate" %>
          %                 if config["router_bgp"]["address_family_ipv4"]["neighbors"][neighbor]["default_originate"].get("route_map") is not None:
          <%                     neighbor_default_originate_cli = neighbor_default_originate_cli + " route-map " + config["router_bgp"]["address_family_ipv4"]["neighbors"][neighbor]["default_originate"]["route_map"] %>
          %                 endif
          %                 if config["router_bgp"]["address_family_ipv4"]["neighbors"][neighbor]["default_originate"].get("always") == True:
          <%                     neighbor_default_originate_cli = neighbor_default_originate_cli + " always" %>
          %                 endif
                ${ neighbor_default_originate_cli }
          %             endif
          %             if config["router_bgp"]["address_family_ipv4"]["neighbors"][neighbor].get("activate") == True:
                neighbor ${ neighbor } activate
          %             elif config["router_bgp"]["address_family_ipv4"]["neighbors"][neighbor].get("activate") == False:
                no neighbor ${ neighbor } activate
          %             endif
          %           endfor
          %       endif
          %     endif
          ## L3VPNs - (vxlan) VRFs
          %     if config["router_bgp"].get("vrfs") is not None:
          %       for vrf in natural_sort(config["router_bgp"]["vrfs"].keys()):
             !
             vrf ${ vrf }
          %         if config["router_bgp"]["vrfs"][vrf].get("rd") is not None:
                rd ${ config["router_bgp"]["vrfs"][vrf]["rd"] }
          %         endif
          %         if config["router_bgp"]["vrfs"][vrf].get("evpn_multicast"):
                evpn multicast
          %             if config["router_bgp"]["vrfs"][vrf].get("evpn_multicast_address_family", {}).get("ipv4", {}).get("transit") is True:
                   address-family ipv4
          %                 if config["router_bgp"]["vrfs"][vrf]["evpn_multicast_address_family"]["ipv4"]["transit"] is True:
                      transit
          %                 endif
          %             endif
          %         endif
          %         if config["router_bgp"]["vrfs"][vrf].get("rd_evpn_domain") is not None:
          %             if config["router_bgp"]["vrfs"][vrf]["rd_evpn_domain"].get('domain') is not None and config["router_bgp"]["vrfs"][vrf]["rd_evpn_domain"].get('rd') is not None:
                rd evpn domain ${ config["router_bgp"]["vrfs"][vrf]["rd_evpn_domain"]["domain"] } ${ config["router_bgp"]["vrfs"][vrf]["rd_evpn_domain"]["rd"] }
          %             endif
          %         endif
          %         if config["router_bgp"]["vrfs"][vrf].get("route_targets") is not None and config["router_bgp"]["vrfs"][vrf]["route_targets"].get("import") is not None:
          %             for address_family in config["router_bgp"]["vrfs"][vrf]["route_targets"]["import"].keys():
          %                 for route_target in config["router_bgp"]["vrfs"][vrf]["route_targets"]["import"][address_family]:
                route-target import ${ address_family } ${ route_target }
          %                 endfor
          %             endfor
          %         endif
          %         if config["router_bgp"]["vrfs"][vrf].get("route_targets") is not None and config["router_bgp"]["vrfs"][vrf]["route_targets"].get("export") is not None:
          %             for address_family in config["router_bgp"]["vrfs"][vrf]["route_targets"]["export"].keys():
          %                 for route_target in config["router_bgp"]["vrfs"][vrf]["route_targets"]["export"][address_family]:
                route-target export ${ address_family } ${ route_target }
          %                 endfor
          %             endfor
          %         endif
          %         if config["router_bgp"]["vrfs"][vrf].get("route_targets") is not None and config["router_bgp"]["vrfs"][vrf]["route_targets"].get("import_evpn_domains") is not None:
          %             for route_target in config["router_bgp"]["vrfs"][vrf]["route_targets"]["import_evpn_domains"]:
                route-target import evpn domain ${ route_target.get('domain') } ${ route_target.get('route_target') }
          %             endfor
          %         endif
          %         if config["router_bgp"]["vrfs"][vrf].get("route_targets") is not None and config["router_bgp"]["vrfs"][vrf]["route_targets"].get("export_evpn_domains") is not None:
          %             for route_target in config["router_bgp"]["vrfs"][vrf]["route_targets"]["export_evpn_domains"]:
                route-target export evpn domain ${ route_target.get('domain') } ${ route_target.get('route_target') }
          %             endfor %}
          %        endif
          %         if config["router_bgp"]["vrfs"][vrf].get("route_targets") is not None and config["router_bgp"]["vrfs"][vrf]["route_targets"].get("import_export_evpn_domains") is not None:
          %             for route_target in config["router_bgp"]["vrfs"][vrf]["route_targets"]["import_export_evpn_domains"]:
                route-target import export evpn domain ${ route_target.get('domain') } ${ route_target.get('route_target') }
          %             endfor %}
          %         endif
          %         if config["router_bgp"]["vrfs"][vrf].get("router_id") is not None:
                router-id ${ config["router_bgp"]["vrfs"][vrf]["router_id"] }
          %         endif
          %         if config["router_bgp"]["vrfs"][vrf].get("timers") is not None:
                timers bgp ${ config["router_bgp"]["vrfs"][vrf]["timers"] }
          %         endif
          %         if config["router_bgp"]["vrfs"][vrf].get("networks") is not None:
          %           for network in config["router_bgp"]["vrfs"][vrf]["networks"].keys():
          %             if config["router_bgp"]["vrfs"][vrf].networks[network].get("route_map") is not None:
                network ${ network } route-map ${ config["router_bgp"]["vrfs"][vrf]["networks"][network]["route_map"] }
          %             else:
                network ${ network }
          %             endif
          %           endfor
          %         endif
          %         if config["router_bgp"]["vrfs"][vrf].get("neighbors") is not None:
          %           for neighbor in config["router_bgp"]["vrfs"][vrf]["neighbors"].keys():
          %             if config["router_bgp"]["vrfs"][vrf]["neighbors"][neighbor].get("remote_as") is not None:
                neighbor ${ neighbor } remote-as ${ config["router_bgp"]["vrfs"][vrf]["neighbors"][neighbor]["remote_as"] }
          %             endif
          %             if config["router_bgp"]["vrfs"][vrf]["neighbors"][neighbor].get("peer_group") is not None:
                neighbor ${ neighbor } peer group ${ config["router_bgp"]["vrfs"][vrf]["neighbors"][neighbor]["peer_group"] }
          %             endif
          %             if config["router_bgp"]["vrfs"][vrf]["neighbors"][neighbor].get("password") is not None:
                neighbor ${ neighbor } password 7 ${ config["router_bgp"]["vrfs"][vrf]["neighbors"][neighbor]["password"] }
          %             endif
          %             if config["router_bgp"]["vrfs"][vrf]["neighbors"][neighbor].get("local_as") is not None:
                neighbor ${ neighbor } local-as ${ config["router_bgp"]["vrfs"][vrf]["neighbors"][neighbor]["local_as"] } no-prepend replace-as
          %             endif
          %             if config["router_bgp"]["vrfs"][vrf]["neighbors"][neighbor].get("description") is not None:
                neighbor ${ neighbor } description ${ config["router_bgp"]["vrfs"][vrf]["neighbors"][neighbor]["description"] }
          %             endif
          %             if config["router_bgp"]["vrfs"][vrf]["neighbors"][neighbor].get("ebgp_multihop") is not None:
          <%                 neighbor_ebgp_multihop_cli = "neighbor " + neighbor + " ebgp-multihop" %>
          %                 if type(config["router_bgp"]["vrfs"][vrf]["neighbors"][neighbor]["ebgp_multihop"]) is int:
          <%                     neighbor_ebgp_multihop_cli = neighbor_ebgp_multihop_cli + " " + config["router_bgp"]["vrfs"][vrf]["neighbors"][neighbor]["ebgp_multihop"] %>
          %                 endif
                ${ neighbor_ebgp_multihop_cli }
          %             endif
          %             if config["router_bgp"]["vrfs"][vrf]["neighbors"][neighbor].get("next_hop_self") == True:
                neighbor ${ neighbor } next-hop-self
          %             endif
          %             if config["router_bgp"]["vrfs"][vrf]["neighbors"][neighbor].get("timers") is not None:
                neighbor ${ neighbor } timers ${ config["router_bgp"]["vrfs"][vrf]["neighbors"][neighbor]["timers"] }
          %             endif
          %             if config["router_bgp"]["vrfs"][vrf]["neighbors"][neighbor].get("send_community") is not None and config["router_bgp"]["vrfs"][vrf]["neighbors"][neighbor]["send_community"] == "all":
                neighbor ${ neighbor } send-community
          %             elif config["router_bgp"]["vrfs"][vrf]["neighbors"][neighbor].get("send_community") is not None:
                neighbor ${ neighbor } send-community ${ config["router_bgp"]["vrfs"][vrf]["neighbors"][neighbor]["send_community"] }
          %             endif
          %             if config["router_bgp"]["vrfs"][vrf]["neighbors"][neighbor].get("maximum_routes") is not None:
          <%                max_routes_cli = f"neighbor {neighbor} maximum-routes {config['router_bgp']['vrfs'][vrf]['neighbors'][neighbor]['maximum_routes']}" %>
          %                 if config["router_bgp"]["vrfs"][vrf]["neighbors"][neighbor].get("maximum_routes_warning_limit") is not None:
          <%                    max_routes_cli += f" warning-limit {config['router_bgp']['vrfs'][vrf]['neighbors'][neighbor]['maximum_routes_warning_limit']}"  %>
          %                 endif
                ${max_routes_cli}
          %             endif
          %             if config["router_bgp"]["vrfs"][vrf]["neighbors"][neighbor].get("default_originate") is not None:
          <%                neighbor_default_originate_cli = "neighbor " + neighbor + " default-originate" %>
          %                 if config["router_bgp"]["vrfs"][vrf]["neighbors"][neighbor]["default_originate"].get("route_map") is not None:
          <%                    neighbor_default_originate_cli = neighbor_default_originate_cli + " route-map " + config["router_bgp"]["vrfs"][vrf]["neighbors"][neighbor]["default_originate"]["route_map"] %>
          %                 endif
          %                 if config["router_bgp"]["vrfs"][vrf]["neighbors"][neighbor]["default_originate"].get("always") == True:
          <%                    neighbor_default_originate_cli = neighbor_default_originate_cli+ " always" %>
          %                 endif
                ${ neighbor_default_originate_cli }
          %             endif
          %             if config["router_bgp"]["vrfs"][vrf]["neighbors"][neighbor].get("update_source") is not None:
                neighbor ${ neighbor } update-source ${ config["router_bgp"]["vrfs"][vrf]["neighbors"][neighbor]["update_source"] }
          %             endif
          %             if config["router_bgp"]["vrfs"][vrf]["neighbors"][neighbor].get("route_map_out") is not None:
                neighbor ${ neighbor } route-map ${ config["router_bgp"]["vrfs"][vrf]["neighbors"][neighbor]["route_map_out"] } out
          %             endif
          %             if config["router_bgp"]["vrfs"][vrf]["neighbors"][neighbor].get("route_map_in") is not None:
                neighbor ${ neighbor } route-map ${ config["router_bgp"]["vrfs"][vrf]["neighbors"][neighbor]["route_map_in"] } in
          %             endif
          %           endfor
          %         endif
          %         if config["router_bgp"]["vrfs"][vrf].get("redistribute_routes") is not None:
          %           for redistribute_route in config["router_bgp"]["vrfs"][vrf]["redistribute_routes"].keys():
          <%             redistribute_cli = "redistribute " + redistribute_route %>
          %              if config["router_bgp"]["vrfs"][vrf]["redistribute_routes"][redistribute_route].get("route_map") is not None:
          <%                 redistribute_cli = redistribute_cli + " route-map " + config["router_bgp"]["vrfs"][vrf]["redistribute_routes"][redistribute_route]["route_map"] %>
          %              endif
                ${ redistribute_cli }
          %           endfor
          %         endif
          %         if config["router_bgp"]["vrfs"][vrf].get("aggregate_addresses") is not None:
          %           for aggregate_address in config["router_bgp"]["vrfs"][vrf]["aggregate_addresses"].keys():
          <%             aggregate_address_cli = "aggregate-address " + aggregate_address %>
          %             if config["router_bgp"]["vrfs"][vrf]["aggregate_addresses"][aggregate_address].get("as_set") == True:
          <%                 aggregate_address_cli = aggregate_address_cli + " as-set" %>
          %             endif
          %             if config["router_bgp"]["vrfs"][vrf]["aggregate_addresses"][aggregate_address].get("summary_only") == True:
          <%                  aggregate_address_cli = aggregate_address_cli + " summary-only" %>
          %             endif
          %             if config["router_bgp"]["vrfs"][vrf]["aggregate_addresses"][aggregate_address].get("attribute_map") is not None:
          <%                  aggregate_address_cli = aggregate_address_cli + " attribute-map " + config["router_bgp"]["vrfs"][vrf]["aggregate_addresses"][aggregate_address]["attribute_map"] %>
          %             endif
          %             if config["router_bgp"]["vrfs"][vrf]["aggregate_addresses"][aggregate_address].get("match_map") is not None:
          <%                  aggregate_address_cli = aggregate_address_cli + " match-map " + config["router_bgp"]["vrfs"][vrf]["aggregate_addresses"][aggregate_address]["match_map"] %>
          %             endif
          %             if config["router_bgp"]["vrfs"][vrf]["aggregate_addresses"][aggregate_address].get("advertise_only") == True:
          <%                 aggregate_address_cli = aggregate_address_cli + " advertise-only" %>
          %             endif
                ${ aggregate_address_cli }
          %           endfor
          %         endif
          %         for statement in config["router_bgp"]["vrfs"][vrf].get('eos_cli', []):
                ${ statement }
          %         endfor
          %         if config["router_bgp"]["vrfs"][vrf].get("address_families") is not None:
          %           for  address_family in config["router_bgp"]["vrfs"][vrf]["address_families"].keys():
                !
                address-family ${ address_family }
          %             for neighbor in config["router_bgp"]["vrfs"][vrf]["address_families"][address_family]["neighbors"].keys():
          %                 if config["router_bgp"]["vrfs"][vrf]["address_families"][address_family]["neighbors"][neighbor].get("activate") == True:
                   neighbor ${ neighbor } activate
          %                 endif
          %             endfor
          %             for network in config["router_bgp"]["vrfs"][vrf]["address_families"][address_family]["networks"].keys():
          <%                network_cli = "network " + network %>
          %                 if config["router_bgp"]["vrfs"][vrf]["address_families"][address_family]["networks"][network].get("route_map") is not None:
          <%                     network_cli = network_cli + " route-map " + config["router_bgp"]["vrfs"][vrf]["address_families"][address_family]["networks"][network]["route_map"] %>
          %                 endif
                   ${ network_cli }
          %             endfor
          %           endfor
          %         endif
          %       endfor
          %     endif
          !
          % endif
          % endif
          ## eos - router multicast
          % if config.get("router_multicast"):
          router multicast
          %     for vrf in natural_sort(config["router_multicast"].get("vrfs", [])):
          %         if vrf["name"] != "default":
             vrf ${ vrf["name"] }
          %             if vrf.get("ipv4"):
                ipv4
          %             endif
          %             if vrf["ipv4"].get("routing") is True:
                   routing
          %             endif
             !
          %         endif
          %     endfor
          !
          % endif
          ## router pim sparse mode
          % if config.get('router_pim_sparse_mode'):
          router pim sparse-mode
          %     for vrf in natural_sort(config["router_pim_sparse_mode"].get("vrfs", [])):
          %         if vrf["name"] != "default":
             vrf ${ vrf["name"] }
          %             if vrf.get("ipv4"):
                ipv4
          %                 if vrf.get("bfd", False) is True:
                   bfd
          %                 endif
          %                 for rp_address in natural_sort(vrf["ipv4"].get("rp_addresses", [])):
          %                     if len(rp_address.get("groups", [])) > 0 or len(rp_address.get("access_lists", [])) > 0:
          %                         if rp_address.get("groups"):
          %                             for group in natural_sort(rp_address["groups"]):
                   rp address ${ rp_address["address"] } ${ group }
          %                             endfor
          %                         endif
          %                         if rp_address.get("access_lists"):
          %                             for access_list in natural_sort(rp_address["access_lists"]):
                   rp address ${ rp_address["address"] } access-list ${ access_list }
          %                             endfor
          %                         endif
          %                     else:
                   rp address ${ rp_address["address"] }
          %                     endif
          %                 endfor
          %             endif
             !
          %         endif
          %     endfor
          !
          % endif
      input_schema:
        fields:
          values:
            tenantName:
              id: tenantName
              name: name
              label: Name
              description: Specify a tenant name.
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options: null
                format: null
                length: null
                pattern: null
                dynamic_options: null
            vrfName:
              id: vrfName
              name: name
              label: Name
              description: VRF Name
              required: true
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options: null
                format: null
                length: null
                pattern: null
                dynamic_options: null
            iBgpSubnet:
              id: iBgpSubnet
              name: iBgpSubnet
              label: Peering Subnet
              description: Define the subnet of the host IP address for the iBGP peering of SVIs with an MLAG peer (if an MLAG peer exists).
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options: null
                format: cidr
                length: null
                pattern: null
                dynamic_options: null
            iBgpVlanId:
              id: iBgpVlanId
              name: iBgpVlanId
              label: Peering VLAN
              description: Determine the VLAN used for iBGP peering with an MLAG peer (if an MLAG peer exists).
              required: false
              type: INPUT_FIELD_TYPE_INTEGER
              integer_props:
                default_value: null
                range: null
                static_options: null
                dynamic_options: null
            iBgpSubnetMask:
              id: iBgpSubnetMask
              name: iBgpSubnetMask
              label: Peering Subnet Mask
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_INTEGER
              integer_props:
                default_value: '31'
                range: null
                static_options:
                  values:
                    - '30'
                    - '31'
                dynamic_options: null
            iBgpDetails:
              id: iBgpDetails
              name: iBgpDetails
              label: MLAG L3 Peering
              description: Create an iBGP peering between MLAG peers for this VRF.
              required: false
              type: INPUT_FIELD_TYPE_GROUP
              group_props:
                members:
                  values:
                    - iBgpSubnet
                    - iBgpVlanId
                    - iBgpSubnetMask
            natInterface:
              id: natInterface
              name: natInterface
              label: Source NAT Loopback ID
              description: Define the loopback interface used for sourcing pings within this VRF.
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options: null
                format: null
                length: null
                pattern: null
                dynamic_options: null
            campusSourceNatSubnet:
              id: campusSourceNatSubnet
              name: subnet
              label: Subnet
              description: Enter an IPv4 pool in CIDR notation (i.e. 172.16.254.0/26).
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options: null
                format: cidr
                length: null
                pattern: null
                dynamic_options: null
            campusSite:
              id: campusSite
              name: site
              label: Site
              description: Set the source NAT interface IPv4 pool for the site. The NodeId tag is used to assign an IP address to the source NAT loopback interface for this VRF. To avoid duplicate addresses being allocated across Sites, enter a unique IPv4 pool per Site.
              required: false
              type: INPUT_FIELD_TYPE_RESOLVER
              resolver_props:
                base_field_id: campusSourceNatSubnet
                display_mode: RESOLVER_FIELD_DISPLAY_MODE_SPARSE
                input_mode: RESOLVER_FIELD_INPUT_MODE_SINGLE_DEVICE_TAG
                input_tag_label: Site
                tag_filter_query: null
            sourceNatCampusResolver:
              id: sourceNatCampusResolver
              name: campus
              label: Campus Source NAT Subnets
              description: Select the campus for which to assign a source NAT interface IPv4 pool.
              required: false
              type: INPUT_FIELD_TYPE_RESOLVER
              resolver_props:
                base_field_id: campusSite
                display_mode: RESOLVER_FIELD_DISPLAY_MODE_SPARSE
                input_mode: RESOLVER_FIELD_INPUT_MODE_SINGLE_DEVICE_TAG
                input_tag_label: Campus
                tag_filter_query: null
            dataCenterSourceNatSubnet:
              id: dataCenterSourceNatSubnet
              name: subnet
              label: IPv4 Pool
              description: Enter an IPv4 pool in CIDR notation (i.e. 172.16.254.0/26).
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options: null
                format: cidr
                length: null
                pattern: null
                dynamic_options: null
            dataCenterPod:
              id: dataCenterPod
              name: dcPoD
              label: DC PoD
              description: Set the source NAT interface IPv4 pool for the data center Pod. The NodeId tag is used to assign an IP address to the source NAT loopback interface for this VRF. To avoid duplicate addresses being allocated across Pods, enter a unique IPv4 pool per DC-Pod.
              required: false
              type: INPUT_FIELD_TYPE_RESOLVER
              resolver_props:
                base_field_id: dataCenterSourceNatSubnet
                display_mode: RESOLVER_FIELD_DISPLAY_MODE_SPARSE
                input_mode: RESOLVER_FIELD_INPUT_MODE_SINGLE_DEVICE_TAG
                input_tag_label: DC-Pod
                tag_filter_query: null
            sourceNatDataCenterResolver:
              id: sourceNatDataCenterResolver
              name: dataCenter
              label: Data Center Source NAT Subnets
              description: Select the data center for which to assign a source NAT interface IPv4 pool.
              required: false
              type: INPUT_FIELD_TYPE_RESOLVER
              resolver_props:
                base_field_id: dataCenterPod
                display_mode: RESOLVER_FIELD_DISPLAY_MODE_SPARSE
                input_mode: RESOLVER_FIELD_INPUT_MODE_SINGLE_DEVICE_TAG
                input_tag_label: DC
                tag_filter_query: null
            natSourceDetails:
              id: natSourceDetails
              name: natSourceDetails
              label: Virtual Source NAT
              description: Create a loopback with virtual source-nat enabled to perform diagnostics from the device.
              required: false
              type: INPUT_FIELD_TYPE_GROUP
              group_props:
                members:
                  values:
                    - natInterface
                    - sourceNatCampusResolver
                    - sourceNatDataCenterResolver
            vrfOverrideRouteDistinguisher:
              id: vrfOverrideRouteDistinguisher
              name: routeDistinguisher
              label: Route Distinguisher
              description: 'Assign a route value to this VRF. Use the format Router-ID: integer (eg. 67: 5013).'
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options: null
                format: null
                length: null
                pattern: null
                dynamic_options: null
            vrfOverrideRouteTarget:
              id: vrfOverrideRouteTarget
              name: routeTarget
              label: Route Target
              description: 'Set a target to import routes from, and to enable other switches to determine if they need to import route updates from this VRF. Use the format integer: VNI or VLAN ID (e.g. 12: 5131).'
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options: null
                format: null
                length: null
                pattern: null
                dynamic_options: null
            vrfOverrideVariables:
              id: vrfOverrideVariables
              name: overrideVariables
              label: Override VRF Attributes
              description: Enter values specific to this VRF to override the default MAC-VRF attributes.
              required: false
              type: INPUT_FIELD_TYPE_GROUP
              group_props:
                members:
                  values:
                    - vrfOverrideRouteDistinguisher
                    - vrfOverrideRouteTarget
            vrfOverrideVNI:
              id: vrfOverrideVNI
              name: vni
              label: VNI
              description: Enter a Virtual Network Identifier to identify networks in the overlay.
              required: true
              type: INPUT_FIELD_TYPE_INTEGER
              integer_props:
                default_value: null
                range: null
                static_options: null
                dynamic_options: null
            vrfL3InterfaceName:
              id: vrfL3InterfaceName
              name: name
              label: Name
              description: Name of the interface or subinterface to configure (i.e. Ethernet1 or Ethernet1.100).
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options: null
                format: null
                length: null
                pattern: null
                dynamic_options: null
            vrfL3InterfaceIpAddress:
              id: vrfL3InterfaceIpAddress
              name: ipAddress
              label: IP Address
              description: Enter an IP address and subnet mask in CIDR notation.
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options: null
                format: cidr
                length: null
                pattern: null
                dynamic_options: null
            vrfL3InterfaceDescription:
              id: vrfL3InterfaceDescription
              name: description
              label: Description
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options: null
                format: null
                length: null
                pattern: null
                dynamic_options: null
            vrfL3InterfaceEnabled:
              id: vrfL3InterfaceEnabled
              name: enabled
              label: Enabled
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_BOOLEAN
              boolean_props:
                default_value: true
            vrfL3InterfaceMtu:
              id: vrfL3InterfaceMtu
              name: mtu
              label: MTU
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_INTEGER
              integer_props:
                default_value: null
                range: null
                static_options: null
                dynamic_options: null
            vrfL3InterfaceCliStatement:
              id: vrfL3InterfaceCliStatement
              name: cliStatement
              label: CLI Statement
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options: null
                format: null
                length: null
                pattern: null
                dynamic_options: null
            vrfL3InterfaceEosCli:
              id: vrfL3InterfaceEosCli
              name: eosCli
              label: EOS CLI
              description: Define EOS CLI statements to be configured under the interface.
              required: false
              type: INPUT_FIELD_TYPE_COLLECTION
              collection_props:
                base_field_id: vrfL3InterfaceCliStatement
                key: ''
            vrfL3InterfaceDetails:
              id: vrfL3InterfaceDetails
              name: interfaceDetails
              label: Interface Details
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_GROUP
              group_props:
                members:
                  values:
                    - vrfL3InterfaceName
                    - vrfL3InterfaceIpAddress
                    - vrfL3InterfaceDescription
                    - vrfL3InterfaceEnabled
                    - vrfL3InterfaceMtu
                    - vrfL3InterfaceEosCli
            vrfL3InterfacesCollection:
              id: vrfL3InterfacesCollection
              name: interfaces
              label: Interfaces
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_COLLECTION
              collection_props:
                base_field_id: vrfL3InterfaceDetails
                key: vrfL3InterfaceName
            vrfL3InterfacesDevice:
              id: vrfL3InterfacesDevice
              name: l3Interfaces
              label: L3 Interfaces
              description: Create an IP routed interface inside the VRF.
              required: false
              type: INPUT_FIELD_TYPE_RESOLVER
              resolver_props:
                base_field_id: vrfL3InterfacesCollection
                display_mode: RESOLVER_FIELD_DISPLAY_MODE_SPARSE
                input_mode: RESOLVER_FIELD_INPUT_MODE_SINGLE_DEVICE_TAG
                input_tag_label: device
                tag_filter_query: null
            vrfRedistributeStaticRoutesToggle:
              id: vrfRedistributeStaticRoutesToggle
              name: redistributeStaticRoutes
              label: Redistribute Static Routes
              description: Non-selectively redistribute static routes.
              required: false
              type: INPUT_FIELD_TYPE_BOOLEAN
              boolean_props:
                default_value: false
            additionalRouteTargetsRouteTarget:
              id: additionalRouteTargetsRouteTarget
              name: routeTarget
              label: Route Target
              description: Use the format <integer>:<integer>.
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options: null
                format: null
                length: null
                pattern: null
                dynamic_options: null
            additionalRouteTargetsType:
              id: additionalRouteTargetsType
              name: type
              label: Type
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options:
                  values:
                    - import
                    - export
                format: null
                length: null
                pattern: null
                dynamic_options: null
            additionalRouteTargetsAddressFamily:
              id: additionalRouteTargetsAddressFamily
              name: addressFamily
              label: Address Family
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: evpn
                static_options: null
                format: null
                length: null
                pattern: null
                dynamic_options: null
            additionalRouteTargetsApply:
              id: additionalRouteTargetsApply
              name: apply
              label: Apply
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_BOOLEAN
              boolean_props:
                default_value: true
            additionalRouteTargetsHostname:
              id: additionalRouteTargetsHostname
              name: hostname
              label: Hostname
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_RESOLVER
              resolver_props:
                base_field_id: additionalRouteTargetsApply
                display_mode: RESOLVER_FIELD_DISPLAY_MODE_ALL
                input_mode: RESOLVER_FIELD_INPUT_MODE_SINGLE_DEVICE_TAG
                input_tag_label: device
                tag_filter_query: null
            additionalRouteTargetsDevicesGroup:
              id: additionalRouteTargetsDevicesGroup
              name: devices
              label: Devices
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_GROUP
              group_props:
                members:
                  values:
                    - additionalRouteTargetsHostname
            additionalRouteTargetsDevicesResolver:
              id: additionalRouteTargetsDevicesResolver
              name: devices
              label: Devices
              description: Select the devices to configure route targets on.
              required: false
              type: INPUT_FIELD_TYPE_RESOLVER
              resolver_props:
                base_field_id: additionalRouteTargetsDevicesGroup
                display_mode: RESOLVER_FIELD_DISPLAY_MODE_SPARSE
                input_mode: RESOLVER_FIELD_INPUT_MODE_MULTI_DEVICE_TAG
                input_tag_label: null
                tag_filter_query: null
            additionalRouteTargetsDetails:
              id: additionalRouteTargetsDetails
              name: routeTargetDetails
              label: Route Target Details
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_GROUP
              group_props:
                members:
                  values:
                    - additionalRouteTargetsRouteTarget
                    - additionalRouteTargetsType
                    - additionalRouteTargetsAddressFamily
                    - additionalRouteTargetsDevicesResolver
            additionalRouteTargets:
              id: additionalRouteTargets
              name: additionalRouteTargets
              label: Additional Route Targets
              description: Configure extra route-targets for this VRF. Useful for route-leaking or gateway between address families.
              required: false
              type: INPUT_FIELD_TYPE_COLLECTION
              collection_props:
                base_field_id: additionalRouteTargetsDetails
                key: ''
            externalBgpPeersNeighborIpAddress:
              id: externalBgpPeersNeighborIpAddress
              name: neighborIpAddress
              label: Neighbor IP Address
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options: null
                format: ip
                length: null
                pattern: null
                dynamic_options: null
            externalBgpPeersRemoteAs:
              id: externalBgpPeersRemoteAs
              name: remoteAs
              label: Remote ASN
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_INTEGER
              integer_props:
                default_value: null
                range: null
                static_options: null
                dynamic_options: null
            externalBgpPeersDescription:
              id: externalBgpPeersDescription
              name: description
              label: Description
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options: null
                format: null
                length: null
                pattern: null
                dynamic_options: null
            externalBgpPeersPassword:
              id: externalBgpPeersPassword
              name: password
              label: Password
              description: Input the encrypted password (seeded with neighbor IP)
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options: null
                format: null
                length: null
                pattern: null
                dynamic_options: null
            externalBgpPeersSendCommunity:
              id: externalBgpPeersSendCommunity
              name: sendCommunity
              label: Send Community
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options:
                  values:
                    - standard
                    - extended
                    - large
                    - all
                format: null
                length: null
                pattern: null
                dynamic_options: null
            externalBgpPeersNextHopSelf:
              id: externalBgpPeersNextHopSelf
              name: nextHopSelf
              label: Next Hop Self
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options:
                  values:
                    - 'True'
                    - 'False'
                format: null
                length: null
                pattern: null
                dynamic_options: null
            externalBgpPeersMaxRoutes:
              id: externalBgpPeersMaxRoutes
              name: maximumRoutes
              label: Maximum Routes
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_INTEGER
              integer_props:
                default_value: null
                range: null
                static_options: null
                dynamic_options: null
            externalBgpPeersWarningLimitRoutes:
              id: externalBgpPeersWarningLimitRoutes
              name: warningLimit
              label: Warning Limit
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_INTEGER
              integer_props:
                default_value: null
                range: null
                static_options: null
                dynamic_options: null
            externalBgpPeersMaxRoutesGroup:
              id: externalBgpPeersMaxRoutesGroup
              name: maxRoutes
              label: Max Routes
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_GROUP
              group_props:
                members:
                  values:
                    - externalBgpPeersMaxRoutes
                    - externalBgpPeersWarningLimitRoutes
            externalBgpPeersUpdateSource:
              id: externalBgpPeersUpdateSource
              name: updateSource
              label: Update Source
              description: Name of source interface
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options: null
                format: null
                length: null
                pattern: null
                dynamic_options: null
            externalBgpPeersEbgpMultihop:
              id: externalBgpPeersEbgpMultihop
              name: ebgpMultihop
              label: EBGP Multihop
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_INTEGER
              integer_props:
                default_value: null
                range: null
                static_options: null
                dynamic_options: null
            externalBgpPeersWeight:
              id: externalBgpPeersWeight
              name: weight
              label: Weight
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_INTEGER
              integer_props:
                default_value: null
                range: null
                static_options: null
                dynamic_options: null
            externalBgpPeersRouteMapIn:
              id: externalBgpPeersRouteMapIn
              name: routeMapIn
              label: Route Map In
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options: null
                format: null
                length: null
                pattern: null
                dynamic_options: null
            externalBgpPeersRouteMapOut:
              id: externalBgpPeersRouteMapOut
              name: routeMapOut
              label: Route Map Out
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options: null
                format: null
                length: null
                pattern: null
                dynamic_options: null
            externalBgpPeersRouteMapGroup:
              id: externalBgpPeersRouteMapGroup
              name: routeMap
              label: Route Map
              description: Enter the name of the route map to configure in/out for the peer.
              required: false
              type: INPUT_FIELD_TYPE_GROUP
              group_props:
                members:
                  values:
                    - externalBgpPeersRouteMapIn
                    - externalBgpPeersRouteMapOut
            ebgpPeerDefaultOriginateEnable:
              id: ebgpPeerDefaultOriginateEnable
              name: ebgpPeerDefaultOriginateEnable
              label: Enable
              description: Enable default-originate for the peer.
              required: false
              type: INPUT_FIELD_TYPE_BOOLEAN
              boolean_props:
                default_value: false
            externalBgpPeersDefaultOriginateAlways:
              id: externalBgpPeersDefaultOriginateAlways
              name: always
              label: Always
              description: The ‘always’ option can be used to always artificially generate a default route and send this artificially generated default route to the neighbor irrespective of another default route being present in the BGP RIB.
              required: false
              type: INPUT_FIELD_TYPE_BOOLEAN
              boolean_props:
                default_value: false
            externalBgpPeersDefaultOriginate:
              id: externalBgpPeersDefaultOriginate
              name: defaultOriginate
              label: Default Originate
              description: The default-originate feature is used to advertise a default route to the neighbor even when a default route is not present in the BGP RIB. If a default route is present in the BGP RIB, this route will be advertised to the neighbor. When a default route is not present in the BGP RIB, one will be artificially generated and advertised to the neighbor for which this feature is configured. This artificially generated default route will not be installed in the BGP RIB.
              required: false
              type: INPUT_FIELD_TYPE_GROUP
              group_props:
                members:
                  values:
                    - ebgpPeerDefaultOriginateEnable
                    - externalBgpPeersDefaultOriginateAlways
            externalBgpPeersNextHopIpv4:
              id: externalBgpPeersNextHopIpv4
              name: iPv4NextHop
              label: IPv4 Next Hop
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options: null
                format: ipv4
                length: null
                pattern: null
                dynamic_options: null
            externalBgpPeersNextHopIpv6:
              id: externalBgpPeersNextHopIpv6
              name: iPv6NextHop
              label: IPv6 Next Hop
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options: null
                format: ipv6
                length: null
                pattern: null
                dynamic_options: null
            externalBgpPeersNextHopGroup:
              id: externalBgpPeersNextHopGroup
              name: nextHop
              label: Next Hop
              description: Next hop settings can be either ipv4 or ipv6 for one neighbor, this will be applied by a uniquely generated route-map per neighbor. Next hop takes precedence over route_map_out.
              required: false
              type: INPUT_FIELD_TYPE_GROUP
              group_props:
                members:
                  values:
                    - externalBgpPeersNextHopIpv4
                    - externalBgpPeersNextHopIpv6
            externalBgpPeersApply:
              id: externalBgpPeersApply
              name: apply
              label: Apply
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_BOOLEAN
              boolean_props:
                default_value: true
            externalBgpPeersHostname:
              id: externalBgpPeersHostname
              name: hostname
              label: Hostname
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_RESOLVER
              resolver_props:
                base_field_id: externalBgpPeersApply
                display_mode: RESOLVER_FIELD_DISPLAY_MODE_ALL
                input_mode: RESOLVER_FIELD_INPUT_MODE_SINGLE_DEVICE_TAG
                input_tag_label: device
                tag_filter_query: null
            externalBgpPeersDevicesGroup:
              id: externalBgpPeersDevicesGroup
              name: devices
              label: Devices
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_GROUP
              group_props:
                members:
                  values:
                    - externalBgpPeersHostname
            externalBgpPeersDevicesResolver:
              id: externalBgpPeersDevicesResolver
              name: devices
              label: Devices
              description: Select the devices to configure the BGP neighbor on.
              required: false
              type: INPUT_FIELD_TYPE_RESOLVER
              resolver_props:
                base_field_id: externalBgpPeersDevicesGroup
                display_mode: RESOLVER_FIELD_DISPLAY_MODE_SPARSE
                input_mode: RESOLVER_FIELD_INPUT_MODE_MULTI_DEVICE_TAG
                input_tag_label: null
                tag_filter_query: null
            externalBgpPeersLocalAs:
              id: externalBgpPeersLocalAs
              name: localAs
              label: Local ASN
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_INTEGER
              integer_props:
                default_value: null
                range: null
                static_options: null
                dynamic_options: null
            externalBgpPeeringName:
              id: externalBgpPeeringName
              name: bgpPeeringName
              label: Name
              description: Name of the BGP peering
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options: null
                format: null
                length: null
                pattern: null
                dynamic_options: null
            externalBgpPeersDetails:
              id: externalBgpPeersDetails
              name: bgpPeerDetails
              label: BGP Peer Details
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_GROUP
              group_props:
                members:
                  values:
                    - externalBgpPeersNeighborIpAddress
                    - externalBgpPeersRemoteAs
                    - externalBgpPeersDescription
                    - externalBgpPeersPassword
                    - externalBgpPeersSendCommunity
                    - externalBgpPeersNextHopSelf
                    - externalBgpPeersMaxRoutesGroup
                    - externalBgpPeersUpdateSource
                    - externalBgpPeersEbgpMultihop
                    - externalBgpPeersWeight
                    - externalBgpPeersRouteMapGroup
                    - externalBgpPeersDefaultOriginate
                    - externalBgpPeersNextHopGroup
                    - externalBgpPeersDevicesResolver
                    - externalBgpPeersLocalAs
                    - externalBgpPeeringName
            externalBgpPeers:
              id: externalBgpPeers
              name: externalBgpPeers
              label: External BGP Peers
              description: Configure BGP neighbors inside the tenant VRF for peering with external devices. The configured peer will automatically be activated for IPv4 or IPv6 address family based on the IP address.
              required: false
              type: INPUT_FIELD_TYPE_COLLECTION
              collection_props:
                base_field_id: externalBgpPeersDetails
                key: externalBgpPeeringName
            staticRoutesDescription:
              id: staticRoutesDescription
              name: description
              label: Description
              description: Unique description for the static route.
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options: null
                format: null
                length: null
                pattern: null
                dynamic_options: null
            staticRoutesApply:
              id: staticRoutesApply
              name: apply
              label: Apply
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_BOOLEAN
              boolean_props:
                default_value: true
            staticRoutesHostname:
              id: staticRoutesHostname
              name: hostname
              label: Hostname
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_RESOLVER
              resolver_props:
                base_field_id: staticRoutesApply
                display_mode: RESOLVER_FIELD_DISPLAY_MODE_ALL
                input_mode: RESOLVER_FIELD_INPUT_MODE_SINGLE_DEVICE_TAG
                input_tag_label: device
                tag_filter_query: null
            staticRoutesDevicesGroup:
              id: staticRoutesDevicesGroup
              name: devices
              label: Devices
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_GROUP
              group_props:
                members:
                  values:
                    - staticRoutesHostname
            staticRoutesDevicesResolver:
              id: staticRoutesDevicesResolver
              name: devices
              label: Devices
              description: Select the devices to configure the static route on.
              required: false
              type: INPUT_FIELD_TYPE_RESOLVER
              resolver_props:
                base_field_id: staticRoutesDevicesGroup
                display_mode: RESOLVER_FIELD_DISPLAY_MODE_SPARSE
                input_mode: RESOLVER_FIELD_INPUT_MODE_MULTI_DEVICE_TAG
                input_tag_label: null
                tag_filter_query: null
            staticRoutesDestinationAddressPrefix:
              id: staticRoutesDestinationAddressPrefix
              name: destinationAddressPrefix
              label: Destination Address Prefix
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options: null
                format: cidr
                length: null
                pattern: null
                dynamic_options: null
            staticRoutesGateway:
              id: staticRoutesGateway
              name: gateway
              label: Gateway
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options: null
                format: null
                length: null
                pattern: null
                dynamic_options: null
            staticRoutesInterface:
              id: staticRoutesInterface
              name: interface
              label: Interface
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options: null
                format: null
                length: null
                pattern: null
                dynamic_options: null
            staticRoutesDistance:
              id: staticRoutesDistance
              name: distance
              label: Distance
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_INTEGER
              integer_props:
                default_value: null
                range: null
                static_options: null
                dynamic_options: null
            staticRoutesTag:
              id: staticRoutesTag
              name: tag
              label: Tag
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_INTEGER
              integer_props:
                default_value: null
                range: null
                static_options: null
                dynamic_options: null
            staticRoutesMetric:
              id: staticRoutesMetric
              name: metric
              label: Metric
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_INTEGER
              integer_props:
                default_value: null
                range: null
                static_options: null
                dynamic_options: null
            staticRoutesDetails:
              id: staticRoutesDetails
              name: routeDetails
              label: Route Details
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_GROUP
              group_props:
                members:
                  values:
                    - staticRoutesDestinationAddressPrefix
                    - staticRoutesGateway
                    - staticRoutesInterface
                    - staticRoutesDistance
                    - staticRoutesTag
                    - staticRoutesMetric
            staticRoutesGroup:
              id: staticRoutesGroup
              name: value
              label: Static Routes Group
              description: Group of members for Static Routes
              required: false
              type: INPUT_FIELD_TYPE_GROUP
              group_props:
                members:
                  values:
                    - staticRoutesDescription
                    - staticRoutesDevicesResolver
                    - staticRoutesDetails
            staticRoutesCollection:
              id: staticRoutesCollection
              name: staticRoutes
              label: Static Routes
              description: Create static routes inside the VRF.
              required: false
              type: INPUT_FIELD_TYPE_COLLECTION
              collection_props:
                base_field_id: staticRoutesGroup
                key: staticRoutesDescription
            vrfAssignApply:
              id: vrfAssignApply
              name: apply
              label: Apply
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_BOOLEAN
              boolean_props:
                default_value: true
            vrfAssignHostname:
              id: vrfAssignHostname
              name: hostname
              label: Hostname
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_RESOLVER
              resolver_props:
                base_field_id: vrfAssignApply
                display_mode: RESOLVER_FIELD_DISPLAY_MODE_ALL
                input_mode: RESOLVER_FIELD_INPUT_MODE_SINGLE_DEVICE_TAG
                input_tag_label: device
                tag_filter_query: null
            vrfAssignDevicesGroup:
              id: vrfAssignDevicesGroup
              name: devices
              label: Devices
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_GROUP
              group_props:
                members:
                  values:
                    - vrfAssignHostname
            vrfAssignDevicesResolver:
              id: vrfAssignDevicesResolver
              name: devices
              label: Devices
              description: Select the devices to apply this VRF to where the VRF won't be automatically applied from VLAN association, static routes, external BGP peerings, or additional route-targets.
              required: false
              type: INPUT_FIELD_TYPE_RESOLVER
              resolver_props:
                base_field_id: vrfAssignDevicesGroup
                display_mode: RESOLVER_FIELD_DISPLAY_MODE_SPARSE
                input_mode: RESOLVER_FIELD_INPUT_MODE_MULTI_DEVICE_TAG
                input_tag_label: null
                tag_filter_query: null
            vrfCliStatement:
              id: vrfCliStatement
              name: cliStatement
              label: CLI Statement
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options: null
                format: null
                length: null
                pattern: null
                dynamic_options: null
            vrfEosCliStatements:
              id: vrfEosCliStatements
              name: eosCli
              label: EOS CLI
              description: Raw EOS CLI statements to be configured under the Router BGP VRF definition.
              required: false
              type: INPUT_FIELD_TYPE_COLLECTION
              collection_props:
                base_field_id: vrfCliStatement
                key: ''
            vrfRouterBgp:
              id: vrfRouterBgp
              name: bgp
              label: BGP
              description: Configure additional BGP parameters for the VRF.
              required: false
              type: INPUT_FIELD_TYPE_GROUP
              group_props:
                members:
                  values:
                    - vrfEosCliStatements
            vrfL3EvpnMulticastEnabled:
              id: vrfL3EvpnMulticastEnabled
              name: enabled
              label: Enabled
              description: Enable or Disable L3 Multicast
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options:
                  values:
                    - 'Yes'
                    - 'No'
                format: null
                length: null
                pattern: null
                dynamic_options: null
            vrfPimRpsGroupName:
              id: vrfPimRpsGroupName
              name: name
              label: RP Group Name
              description: Group Name
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options: null
                format: null
                length: null
                pattern: null
                dynamic_options: null
            vrfPimRpsIpAddressesIpAddress:
              id: vrfPimRpsIpAddressesIpAddress
              name: ipAddress
              label: IP Address
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options: null
                format: ip
                length: null
                pattern: null
                dynamic_options: null
            vrfPimRpsIpAddressesCollection:
              id: vrfPimRpsIpAddressesCollection
              name: rpIpAddresses
              label: RP IP Addresses
              description: A minimum of one RP must be specified
              required: false
              type: INPUT_FIELD_TYPE_COLLECTION
              collection_props:
                base_field_id: vrfPimRpsIpAddressesIpAddress
                key: ''
            vrfPimRpsGroupAddressesGroupAddress:
              id: vrfPimRpsGroupAddressesGroupAddress
              name: groupAddress
              label: Group Address
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options: null
                format: cidr
                length: null
                pattern: null
                dynamic_options: null
            vrfPimRpsGroupAddressesCollection:
              id: vrfPimRpsGroupAddressesCollection
              name: groupAddresses
              label: Group Addresses
              description: 'List of groups to associate with the RP address.'
              required: false
              type: INPUT_FIELD_TYPE_COLLECTION
              collection_props:
                base_field_id: vrfPimRpsGroupAddressesGroupAddress
                key: ''
            vrfPimRpAddressesDetails:
              id: vrfPimRpAddressesDetails
              name: pimRpAddressesDetails
              label: PIM RP Addresses Details
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_GROUP
              group_props:
                members:
                  values:
                    - vrfPimRpsGroupName
                    - vrfPimRpsIpAddressesCollection
                    - vrfPimRpsGroupAddressesCollection
            vrfPimRpAddressesCollection:
              id: vrfPimRpAddressesCollection
              name: pimRpAddresses
              label: PIM RP Addresses
              description: For each group of nodes, allow configuration of RP Addresses & associated groups.
              required: false
              type: INPUT_FIELD_TYPE_COLLECTION
              collection_props:
                base_field_id: vrfPimRpAddressesDetails
                key: ''
            vrfEvpnPegTransitMode:
              id: vrfEvpnPegTransitMode
              name: transit
              label: Transit
              description: Enable EVPN PEG transit mode
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options:
                  values:
                    - 'Yes'
                    - 'No'
                format: null
                length: null
                pattern: null
                dynamic_options: null
            vrfEvpnPegResolver:
              id: vrfEvpnPegResolver
              name: evpnPeg
              label: EVPN PEG
              description: For each group of nodes, allow configuration of EVPN PEG features. Restrict configuration to specific nodes. Will apply to all nodes with RP addresses configured if not set.
              required: false
              type: INPUT_FIELD_TYPE_RESOLVER
              resolver_props:
                base_field_id: vrfEvpnPegTransitMode
                display_mode: RESOLVER_FIELD_DISPLAY_MODE_SPARSE
                input_mode: RESOLVER_FIELD_INPUT_MODE_MULTI_DEVICE_TAG
                input_tag_label: null
                tag_filter_query: null
            vrfEvpnMulticastDetails:
              id: vrfEvpnMulticastDetails
              name: evpnMulticast
              label: EVPN Multicast
              description: Explicitly enable or disable EVPN L3 Multicast to override Tenant Settings
              required: false
              type: INPUT_FIELD_TYPE_GROUP
              group_props:
                members:
                  values:
                    - vrfL3EvpnMulticastEnabled
                    - vrfPimRpAddressesCollection
                    - vrfEvpnPegResolver
            vrfGroup:
              id: vrfGroup
              name: vrfGroup
              label: VRF Definition
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_GROUP
              group_props:
                members:
                  values:
                    - vrfName
                    - iBgpDetails
                    - natSourceDetails
                    - vrfOverrideVariables
                    - vrfOverrideVNI
                    - vrfL3InterfacesDevice
                    - vrfRedistributeStaticRoutesToggle
                    - additionalRouteTargets
                    - externalBgpPeers
                    - staticRoutesCollection
                    - vrfAssignDevicesResolver
                    - vrfRouterBgp
                    - vrfEvpnMulticastDetails
            vrfs:
              id: vrfs
              name: vrfs
              label: VRFs
              description: Define L3 network services organized by VRF.
              required: false
              type: INPUT_FIELD_TYPE_COLLECTION
              collection_props:
                base_field_id: vrfGroup
                key: vrfName
            vlanAwareBundleVlanRange:
              id: vlanAwareBundleVlanRange
              name: vlanRange
              label: VLAN Range
              description: Assign VLANs to this bundle with their VLAN IDs. Specify separate VLANs with a comma and series with a hyphen (e.g 1-9, 14, 23-40).
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options: null
                format: null
                length: null
                pattern: null
                dynamic_options: null
            vlanAwareBundleName:
              id: vlanAwareBundleName
              name: name
              label: Name
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options: null
                format: null
                length: null
                pattern: null
                dynamic_options: null
            vlanAwareBundleOverrideRouteDistinguisher:
              id: vlanAwareBundleOverrideRouteDistinguisher
              name: routeDistinguisher
              label: Route Distinguisher
              description: 'Assign a route value to this VRF. Use the format Router-ID: integer (eg. 67: 5013).'
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options: null
                format: null
                length: null
                pattern: null
                dynamic_options: null
            vlanAwareBundleOverrideRouteTarget:
              id: vlanAwareBundleOverrideRouteTarget
              name: routeTarget
              label: Route Target
              description: 'Set a target to import routes from, and to enable other switches to determine if they need to import route updates from this VRF. Use the format integer: VNI or VLAN ID (e.g. 12: 5131)'
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options: null
                format: null
                length: null
                pattern: null
                dynamic_options: null
            vlanAwareBundleOverrideVariables:
              id: vlanAwareBundleOverrideVariables
              name: overrideVariables
              label: Overide MAC-VRF Attributes
              description: Enter values specific to this VRF to overide the default MAC-VRF attributes.
              required: false
              type: INPUT_FIELD_TYPE_GROUP
              group_props:
                members:
                  values:
                    - vlanAwareBundleOverrideRouteDistinguisher
                    - vlanAwareBundleOverrideRouteTarget
            vlanAwareBundleGroup:
              id: vlanAwareBundleGroup
              name: vlanGroup
              label: VLAN Bundle Definition
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_GROUP
              group_props:
                members:
                  values:
                    - vlanAwareBundleVlanRange
                    - vlanAwareBundleName
                    - vlanAwareBundleOverrideVariables
            vlanAwareBundles:
              id: vlanAwareBundles
              name: vlanAwareBundles
              label: VLAN Aware Bundles
              description: Configure a bundle of VLANs that share the same MAC-VRF attributes.
              required: false
              type: INPUT_FIELD_TYPE_COLLECTION
              collection_props:
                base_field_id: vlanAwareBundleGroup
                key: vlanAwareBundleName
            vlanId:
              id: vlanId
              name: vlanId
              label: VLAN ID
              description: VLAN ID
              required: false
              type: INPUT_FIELD_TYPE_INTEGER
              integer_props:
                default_value: null
                range: null
                static_options: null
                dynamic_options: null
            vlanBasedVlanName:
              id: vlanBasedVlanName
              name: name
              label: Name
              description: Enter a one-word name for the VLAN.
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options: null
                format: null
                length: null
                pattern: null
                dynamic_options: null
            vlanMemberSwitchApply:
              id: vlanMemberSwitchApply
              name: apply
              label: Apply
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_BOOLEAN
              boolean_props:
                default_value: true
            vlanMemberSwitchHostname:
              id: vlanMemberSwitchHostname
              name: hostname
              label: Hostname
              description: The service will not be configured unless Apply is selected.
              required: false
              type: INPUT_FIELD_TYPE_RESOLVER
              resolver_props:
                base_field_id: vlanMemberSwitchApply
                display_mode: RESOLVER_FIELD_DISPLAY_MODE_ALL
                input_mode: RESOLVER_FIELD_INPUT_MODE_SINGLE_DEVICE_TAG
                input_tag_label: device
                tag_filter_query: null
            vlanMemberSwitch:
              id: vlanMemberSwitch
              name: switch
              label: Devices
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_GROUP
              group_props:
                members:
                  values:
                    - vlanMemberSwitchHostname
            vlanMemberSwitches:
              id: vlanMemberSwitches
              name: switches
              label: VTEPs
              description: Assign the VLAN to devices.
              required: false
              type: INPUT_FIELD_TYPE_RESOLVER
              resolver_props:
                base_field_id: vlanMemberSwitch
                display_mode: RESOLVER_FIELD_DISPLAY_MODE_SPARSE
                input_mode: RESOLVER_FIELD_INPUT_MODE_MULTI_DEVICE_TAG
                input_tag_label: null
                tag_filter_query: null
            vlanDhcpServers:
              id: vlanDhcpServers
              name: dhcpServer
              label: DHCP Server
              description: Enter the FQDN or the IP address of the DHCP server.
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options: null
                format: null
                length: null
                pattern: null
                dynamic_options: null
            vlanDhcpHelperSourceInterface:
              id: vlanDhcpHelperSourceInterface
              name: sourceInterface
              label: Source Interface
              description: Enter an interface to source DHCP relays from
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options: null
                format: null
                length: null
                pattern: null
                dynamic_options: null
            vlanDhcpServerDetail:
              id: vlanDhcpServerDetail
              name: dhcpServerDetail
              label: DHCP Server Detail
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_GROUP
              group_props:
                members:
                  values:
                    - vlanDhcpServers
                    - vlanDhcpHelperSourceInterface
            vlanDhcpServerDetails:
              id: vlanDhcpServerDetails
              name: dhcpServerDetails
              label: DHCP Helper Details
              description: Specify the location of the DHCP server for this VLAN.
              required: false
              type: INPUT_FIELD_TYPE_COLLECTION
              collection_props:
                base_field_id: vlanDhcpServerDetail
                key: vlanDhcpServers
            vlanL3OrL2:
              id: vlanL3OrL2
              name: l3OrL2
              label: Routed or Bridged
              description: If set to 'Routed', both the L3 SVI and L2 VLAN will be configured on a selected L3 device. If set to 'Bridged', only the L2 VLAN will be configured on a selected L3 device. Only the L2 VLAN will be configured on any L2 devices downstream of the selected L3 device.
              required: false
              type: INPUT_FIELD_TYPE_BOOLEAN
              boolean_props:
                default_value: true
            vlanSviVirtualIpAddress:
              id: vlanSviVirtualIpAddress
              name: sviVirtualIpAddress
              label: SVI Virtual IP Address
              description: Assign a virtual IP address to be used on the VLAN's SVI. This will be the default gateway for devices behind this VTEP on this VLAN. If the address type is 'ip address virtual' use CIDR notation (i.e. 192.168.0.1/24). If the address type is 'ip virtual-router address', enter either just an IP address (i.e. 192.168.0.1) or an IP address in CIDR notation (192.168.0.1/24).  If 'ip virtual-router address' is selected and an IP Address is entered in CIDR notation, make sure to enter the appropriate values for the Primary Switch SVI IP Address field and the Secondary Switch SVI IP Address field.
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options: null
                format: null
                length: null
                pattern: null
                dynamic_options: null
            vlanVirtualAddressConfigType:
              id: vlanVirtualAddressConfigType
              name: virtualAddressConfigType
              label: Virtual Address Config Type
              description: Set the virtual address type to be used to implement VARP.
              required: false
              type: INPUT_FIELD_TYPE_BOOLEAN
              boolean_props:
                default_value: true
            vlanPrimarySwitchSviIpAddress:
              id: vlanPrimarySwitchSviIpAddress
              name: primarySwitchSviIpAddress
              label: Primary Switch SVI IP Address
              description: The real IP address of SVI on the primary switch of an MLAG pair.
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options: null
                format: cidr
                length: null
                pattern: null
                dynamic_options: null
            vlanSecondarySwitchSviIpAddress:
              id: vlanSecondarySwitchSviIpAddress
              name: secondarySwitchSviIpAddress
              label: Secondary Switch SVI IP Address
              description: The real IP address of SVI on the secondary switch of an MLAG pair.
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options: null
                format: cidr
                length: null
                pattern: null
                dynamic_options: null
            vlanSVIIpAddresses:
              id: vlanSVIIpAddresses
              name: sviIpAddresses
              label: SVI Addresses
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_GROUP
              group_props:
                members:
                  values:
                    - vlanSviVirtualIpAddress
                    - vlanVirtualAddressConfigType
                    - vlanPrimarySwitchSviIpAddress
                    - vlanSecondarySwitchSviIpAddress
            vlanOverrideVni:
              id: vlanOverrideVni
              name: vni
              label: VNI
              description: Enter a Virtual Network Identifier to identify networks in the overlay
              required: false
              type: INPUT_FIELD_TYPE_INTEGER
              integer_props:
                default_value: null
                range: null
                static_options: null
                dynamic_options: null
            vlanOverrideRouteDistinguisher:
              id: vlanOverrideRouteDistinguisher
              name: routeDistinguisher
              label: Route Distinguisher
              description: 'Assign a route value to this VRF. Use the format Router-ID: integer (eg. 67: 5013).'
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options: null
                format: null
                length: null
                pattern: null
                dynamic_options: null
            vlanOverrideRouteTarget:
              id: vlanOverrideRouteTarget
              name: routeTarget
              label: Route Target
              description: 'Set a target to import routes from, and to enable other switches to determine if they need to import route updates from this VRF. Use the format integer: VNI or VLAN ID (e.g. 12: 5131)'
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options: null
                format: null
                length: null
                pattern: null
                dynamic_options: null
            vlanOverrideVariables:
              id: vlanOverrideVariables
              name: overrideVariables
              label: Override Attributes
              description: Enter values specific to this VLAN and VRF to override the default generated attributes.
              required: false
              type: INPUT_FIELD_TYPE_GROUP
              group_props:
                members:
                  values:
                    - vlanOverrideVni
                    - vlanOverrideRouteDistinguisher
                    - vlanOverrideRouteTarget
            vlanSviMtu:
              id: vlanSviMtu
              name: mtu
              label: MTU
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_INTEGER
              integer_props:
                default_value: '9214'
                range: null
                static_options: null
                dynamic_options: null
            vlanSviArpAgingTimeout:
              id: vlanSviArpAgingTimeout
              name: arpAgingTimeout
              label: ARP Aging Timeout
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_INTEGER
              integer_props:
                default_value: null
                range: null
                static_options: null
                dynamic_options: null
            vlanSviArpDetails:
              id: vlanSviArpDetails
              name: arp
              label: ARP
              description: Set the ARP aging timeout (seconds) for ARP entries for this VLAN.
              required: false
              type: INPUT_FIELD_TYPE_GROUP
              group_props:
                members:
                  values:
                    - vlanSviArpAgingTimeout
            vlanSviCliStatement:
              id: vlanSviCliStatement
              name: cliStatement
              label: CLI Statement
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options: null
                format: null
                length: null
                pattern: null
                dynamic_options: null
            vlanSviEosCliStatements:
              id: vlanSviEosCliStatements
              name: eosCli
              label: EOS CLI
              description: Enter EOS commands to configure under the VLAN interface.
              required: false
              type: INPUT_FIELD_TYPE_COLLECTION
              collection_props:
                base_field_id: vlanSviCliStatement
                key: ''
            vlanVrf:
              id: vlanVrf
              name: vrf
              label: VRF
              description: Assign the VLAN to a VRF.
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options: null
                format: null
                length: null
                pattern: null
                dynamic_options:
                  values:
                    - '{"fieldId":"vrfName"}'
            vlanVxlanToggle:
              id: vlanVxlanToggle
              name: vxlan
              label: VXLAN
              description: Extend this VLAN over the VXLAN overlay. If not extending, SVI parameters are defined by selecting each VTEP and separately configuring.
              required: false
              type: INPUT_FIELD_TYPE_BOOLEAN
              boolean_props:
                default_value: true
            nodeSviIpAddress:
              id: nodeSviIpAddress
              name: ipAddress
              label: IP Address
              description: Enter an IP address and subnet mask in CIDR notation for the SVI (i.e. 1.1.1.1/24).
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options: null
                format: cidr
                length: null
                pattern: null
                dynamic_options: null
            nodeVirtualSviIpAddress:
              id: nodeVirtualSviIpAddress
              name: virtualIpAddress
              label: Virtual IP Address
              description: Enter an IP address and optionally a subnet mask for the SVI (i.e. 1.1.1.1 or 1.1.1.1/24).
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options: null
                format: null
                length: null
                pattern: null
                dynamic_options: null
            nodeSviIpInfo:
              id: nodeSviIpInfo
              name: sviIpInfo
              label: SVI IP Info
              description: Override dynamically allocated addresses
              required: false
              type: INPUT_FIELD_TYPE_GROUP
              group_props:
                members:
                  values:
                    - nodeSviIpAddress
                    - nodeVirtualSviIpAddress
            nodeVlanDetails:
              id: nodeVlanDetails
              name: nodes
              label: Node SVI Addresses
              description: Override dynamically allocated addresses
              required: false
              type: INPUT_FIELD_TYPE_RESOLVER
              resolver_props:
                base_field_id: nodeSviIpInfo
                display_mode: RESOLVER_FIELD_DISPLAY_MODE_SPARSE
                input_mode: RESOLVER_FIELD_INPUT_MODE_SINGLE_DEVICE_TAG
                input_tag_label: device
                tag_filter_query: null
            etreeEnable:
              id: etreeEnable
              name: etreeEnable
              label: Enable
              description: Enable Etree for this VLAN.
              required: false
              type: INPUT_FIELD_TYPE_BOOLEAN
              boolean_props:
                default_value: false
            leafExportRouteTargetOffset:
              id: leafExportRouteTargetOffset
              name: leafExportRouteTargetOffset
              label: Leaf Export Route Target Offset
              description: This number is added to the second half of the leaf export route target.
              required: false
              type: INPUT_FIELD_TYPE_INTEGER
              integer_props:
                default_value: '10000'
                range: null
                static_options: null
                dynamic_options: null
            eTreeDetails:
              id: eTreeDetails
              name: eTreeDetails
              label: Etree
              description: Enable Etree for this VLAN. All VTEPs will be a Leaf node by default. Root switches are specified below.
              required: false
              type: INPUT_FIELD_TYPE_GROUP
              group_props:
                members:
                  values:
                    - etreeEnable
                    - leafExportRouteTargetOffset
            etreeRole:
              id: etreeRole
              name: role
              label: Role
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options:
                  values:
                    - Root
                format: null
                length: null
                pattern: null
                dynamic_options: null
            etreeRootSwitches:
              id: etreeRootSwitches
              name: eTreeRootSwitches
              label: E Tree Root Switches
              description: Specify which switches are Etree Root for this VLAN.
              required: false
              type: INPUT_FIELD_TYPE_RESOLVER
              resolver_props:
                base_field_id: etreeRole
                display_mode: RESOLVER_FIELD_DISPLAY_MODE_SPARSE
                input_mode: RESOLVER_FIELD_INPUT_MODE_SINGLE_DEVICE_TAG
                input_tag_label: null
                tag_filter_query: null
            vlanL2EvpnMulticastEnabled:
              id: vlanL2EvpnMulticastEnabled
              name: l2Enabled
              label: Enabled
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options:
                  values:
                    - 'Yes'
                    - 'No'
                format: null
                length: null
                pattern: null
                dynamic_options: null
            vlanL3EvpnMulticastEnabled:
              id: vlanL3EvpnMulticastEnabled
              name: l3Enabled
              label: Enabled
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options:
                  values:
                    - 'Yes'
                    - 'No'
                format: null
                length: null
                pattern: null
                dynamic_options: null
            vlanEvpnMulticastDetails:
              id: vlanEvpnMulticastDetails
              name: evpnMulticast
              label: EVPN Multicast
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_GROUP
              group_props:
                members:
                  values:
                    - vlanL2EvpnMulticastEnabled
                    - vlanL3EvpnMulticastEnabled
            vlanBasedVlans:
              id: vlanBasedVlans
              name: vlanBasedVlaNs
              label: VLAN Definitions
              description: VLAN based VLANs
              required: false
              type: INPUT_FIELD_TYPE_GROUP
              group_props:
                members:
                  values:
                    - vlanId
                    - vlanBasedVlanName
                    - vlanMemberSwitches
                    - vlanDhcpServerDetails
                    - vlanL3OrL2
                    - vlanSVIIpAddresses
                    - vlanOverrideVariables
                    - vlanSviMtu
                    - vlanSviArpDetails
                    - vlanSviEosCliStatements
                    - vlanVrf
                    - vlanVxlanToggle
                    - nodeVlanDetails
                    - eTreeDetails
                    - etreeRootSwitches
                    - vlanEvpnMulticastDetails
            vlans:
              id: vlans
              name: vlans
              label: VLANs
              description: Define L2 network services organized by VLAN ID.
              required: false
              type: INPUT_FIELD_TYPE_COLLECTION
              collection_props:
                base_field_id: vlanBasedVlans
                key: vlanId
            macVrfVniBase:
              id: macVrfVniBase
              name: macVrfVniBase
              label: MAC-VRF VNI Base
              description: Set the default number that generates each Virtual Network Identifier by adding it to the specific VLAN ID.
              required: false
              type: INPUT_FIELD_TYPE_INTEGER
              integer_props:
                default_value: '10000'
                range: null
                static_options: null
                dynamic_options: null
            tenantL3EvpnMulticastEnabled:
              id: tenantL3EvpnMulticastEnabled
              name: enabled
              label: Enabled
              description: Enable/Disable L3 Multicast (OISM)
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: 'No'
                static_options:
                  values:
                    - 'Yes'
                    - 'No'
                format: null
                length: null
                pattern: null
                dynamic_options: null
            tenantEvpnPegTransitMode:
              id: tenantEvpnPegTransitMode
              name: transit
              label: Transit
              description: Enable EVPN PEG transit mode
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: 'No'
                static_options:
                  values:
                    - 'Yes'
                    - 'No'
                format: null
                length: null
                pattern: null
                dynamic_options: null
            tenantEvpnPegResolver:
              id: tenantEvpnPegResolver
              name: evpnPeg
              label: EVPN PEG
              description: For each group of nodes, allow configuration of EVPN PEG features. Restrict configuration to specific nodes. Will apply to all nodes with RP addresses configured if not set.
              required: false
              type: INPUT_FIELD_TYPE_RESOLVER
              resolver_props:
                base_field_id: tenantEvpnPegTransitMode
                display_mode: RESOLVER_FIELD_DISPLAY_MODE_SPARSE
                input_mode: RESOLVER_FIELD_INPUT_MODE_MULTI_DEVICE_TAG
                input_tag_label: null
                tag_filter_query: null
            tenantPimRpsGroupName:
              id: tenantPimRpsGroupName
              name: name
              label: Group Name
              description: Group Name
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options: null
                format: null
                length: null
                pattern: null
                dynamic_options: null
            tenantPimRpsIpAddressesIpAddress:
              id: tenantPimRpsIpAddressesIpAddress
              name: ipAddress
              label: IP Address
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options: null
                format: ip
                length: null
                pattern: null
                dynamic_options: null
            tenantPimRpsIpAddressesCollection:
              id: tenantPimRpsIpAddressesCollection
              name: rpIpAddresses
              label: RP IP Addresses
              description: List of Rendevouz Points
              required: false
              type: INPUT_FIELD_TYPE_COLLECTION
              collection_props:
                base_field_id: tenantPimRpsIpAddressesIpAddress
                key: ''
            tenantPimRpsGroupAddressesGroupAddress:
              id: tenantPimRpsGroupAddressesGroupAddress
              name: groupAddress
              label: Group Address
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options: null
                format: cidr
                length: null
                pattern: null
                dynamic_options: null
            tenantPimRpsGroupAddressesCollection:
              id: tenantPimRpsGroupAddressesCollection
              name: groupAddresses
              label: Group Addresses
              description: 'List of groups to associate with the RP address.'
              required: false
              type: INPUT_FIELD_TYPE_COLLECTION
              collection_props:
                base_field_id: tenantPimRpsGroupAddressesGroupAddress
                key: ''
            tenantPimRpAddressesDetails:
              id: tenantPimRpAddressesDetails
              name: pimRpAddressesDetails
              label: PIM RP Addresses Details
              description: Group of members for PIM RP Addresses
              required: false
              type: INPUT_FIELD_TYPE_GROUP
              group_props:
                members:
                  values:
                    - tenantPimRpsGroupName
                    - tenantPimRpsIpAddressesCollection
                    - tenantPimRpsGroupAddressesCollection
            tenantPimRpAddressesCollection:
              id: tenantPimRpAddressesCollection
              name: pimRpAddresses
              label: PIM RP Addresses
              description: For each group of nodes, allow configuration of RP Addresses & associated groups.
              required: false
              type: INPUT_FIELD_TYPE_COLLECTION
              collection_props:
                base_field_id: tenantPimRpAddressesDetails
                key: ''
            tenantL3EvpnMulticastGroupIpv4Pool:
              id: tenantL3EvpnMulticastGroupIpv4Pool
              name: evpnUnderlayL3MulticastGroupIpv4Pool
              label: Multicast Group Pool
              description: 'Pool to assign overlay multicast address bindings from. Pool is assigned using the following formula: < l3_multicast.evpn_underlay_l3_multicast_group_ipv4_pool > + < vrf_vni - 1 > + < l3_multicast.evpn_underlay_l3_multicast_group_ipv4_pool_offset >. The recommendation is to assign a /20 block within the 232.0.0.0/8 Source-Specific Multicast range.'
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options: null
                format: cidr
                length: null
                pattern: null
                dynamic_options: null
            tenantL3EvpnMulticastGroupIpv4PoolOffset:
              id: tenantL3EvpnMulticastGroupIpv4PoolOffset
              name: evpnUnderlayL3MulticastGroupIpv4PoolOffset
              label: Multicast Group Pool Offset
              description: 'Offset used in the VXLAN, VLAN, multicast group IPv4 address binding formula (Value should be an integer)'
              required: false
              type: INPUT_FIELD_TYPE_INTEGER
              integer_props:
                default_value: null
                range: null
                static_options: null
                dynamic_options: null
            tenantL3EvpnMulticast:
              id: tenantL3EvpnMulticast
              name: evpnUnderlayMulticast
              label: EVPN Underlay Multicast
              description: Configure underlay multicast groups
              required: false
              type: INPUT_FIELD_TYPE_GROUP
              group_props:
                members:
                  values:
                    - tenantL3EvpnMulticastGroupIpv4Pool
                    - tenantL3EvpnMulticastGroupIpv4PoolOffset
            tenantL3EvpnMulticastDetails:
              id: tenantL3EvpnMulticastDetails
              name: l3Multicast
              label: L3 Multicast
              description: Enable L3 Multicast (OISM) for all SVIs and l3vlans within Tenant
              required: false
              type: INPUT_FIELD_TYPE_GROUP
              group_props:
                members:
                  values:
                    - tenantL3EvpnMulticastEnabled
                    - tenantEvpnPegResolver
                    - tenantPimRpAddressesCollection
                    - tenantL3EvpnMulticast
            tenantL2EvpnMulticastEnabled:
              id: tenantL2EvpnMulticastEnabled
              name: enabled
              label: Enabled
              description: Enable/Disable EVPN L2 Multicast
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: 'No'
                static_options:
                  values:
                    - 'Yes'
                    - 'No'
                format: null
                length: null
                pattern: null
                dynamic_options: null
            tenantL2EvpnMulticastGroupIpv4Pool:
              id: tenantL2EvpnMulticastGroupIpv4Pool
              name: evpnUnderlayL2MulticastGroupIpv4Pool
              label: Multicast Group Pool
              description: 'Pool to assign overlay multicast address bindings from. Pool is assigned using the following formula:  <evpn_l2_multicast.underlay_l2_multicast_group_ipv4_pool > + < vlan_id - 1 > + < evpn_l2_multicast.underlay_l2_multicast_group_ipv4_pool_offset >. The recommendation is to assign a /20 block within the 232.0.0.0/8 Source-Specific Multicast range.'
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options: null
                format: cidr
                length: null
                pattern: null
                dynamic_options: null
            tenantL2EvpnMulticastGroupIpv4PoolOffset:
              id: tenantL2EvpnMulticastGroupIpv4PoolOffset
              name: evpnUnderlayL2MulticastGroupIpv4PoolOffset
              label: Multicast Group Pool Offset
              description: 'Offset used in the VXLAN, VLAN, multicast group IPv4 address binding formula (Value should be an integer)'
              required: false
              type: INPUT_FIELD_TYPE_INTEGER
              integer_props:
                default_value: null
                range: null
                static_options: null
                dynamic_options: null
            tenantL2EvpnMulticast:
              id: tenantL2EvpnMulticast
              name: evpnUnderlayMulticast
              label: EVPN Underlay Multicast
              description: Configure the underlay multicast groups
              required: false
              type: INPUT_FIELD_TYPE_GROUP
              group_props:
                members:
                  values:
                    - tenantL2EvpnMulticastGroupIpv4Pool
                    - tenantL2EvpnMulticastGroupIpv4PoolOffset
            tenantL2EvpnMulticastDetails:
              id: tenantL2EvpnMulticastDetails
              name: l2Multicast
              label: L2 Multicast
              description: Enable EVPN L2 Multicast for all SVIs and l2vlans within Tenant.
              required: false
              type: INPUT_FIELD_TYPE_GROUP
              group_props:
                members:
                  values:
                    - tenantL2EvpnMulticastEnabled
                    - tenantL2EvpnMulticast
            tenantEvpnMulticastDetails:
              id: tenantEvpnMulticastDetails
              name: evpnMulticast
              label: EVPN Multicast
              description: 'Configure L2/L3 EVPN Multicast '
              required: false
              type: INPUT_FIELD_TYPE_GROUP
              group_props:
                members:
                  values:
                    - tenantL3EvpnMulticastDetails
                    - tenantL2EvpnMulticastDetails
            tenantDefinition:
              id: tenantDefinition
              name: tenantDefinition
              label: Tenant Definition
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_GROUP
              group_props:
                members:
                  values:
                    - tenantName
                    - vrfs
                    - vlanAwareBundles
                    - vlans
                    - macVrfVniBase
                    - tenantEvpnMulticastDetails
            tenants:
              id: tenants
              name: tenants
              label: Tenants
              description: Network services are grouped by tenants. This allows for granular deployment of network service to the fabric leveraging the tenant name and tags applied to the service definition.
              required: false
              type: INPUT_FIELD_TYPE_COLLECTION
              collection_props:
                base_field_id: tenantDefinition
                key: tenantName
            vrfRouteDistinguisherFormat:
              id: vrfRouteDistinguisherFormat
              name: vrfRouteDistinguisherFormat
              label: VRF Route Distinguisher Format
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: Router-ID:VNI
                static_options:
                  values:
                    - Router-ID:VNI
                    - VTEP Source IP:VNI
                format: null
                length: null
                pattern: null
                dynamic_options: null
            vrfRouteTargetFormat:
              id: vrfRouteTargetFormat
              name: vrfRouteTargetFormat
              label: VRF Route Target Format
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: VNI:VNI
                static_options:
                  values:
                    - VNI:VNI
                format: null
                length: null
                pattern: null
                dynamic_options: null
            vrfAttributeFormats:
              id: vrfAttributeFormats
              name: vrfAttributeFormats
              label: VRF Attributes
              description: Set the default format for how VRF attributes are generated.
              required: false
              type: INPUT_FIELD_TYPE_GROUP
              group_props:
                members:
                  values:
                    - vrfRouteDistinguisherFormat
                    - vrfRouteTargetFormat
            vlanBasedMacVrfRouteDistinguisherFormat:
              id: vlanBasedMacVrfRouteDistinguisherFormat
              name: macVrfRouteDistinguisherFormat
              label: MAC-VRF Route Distinguisher Format
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: Router-ID:VNI
                static_options:
                  values:
                    - Router-ID:VNI
                    - Router-ID:VLAN
                    - VTEP Source IP:VNI
                    - VTEP Source IP:VLAN
                format: null
                length: null
                pattern: null
                dynamic_options: null
            vlanBasedMacVrfRouteTargetFormat:
              id: vlanBasedMacVrfRouteTargetFormat
              name: macVrfRouteTargetFormat
              label: MAC-VRF Route Target Format
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: VNI:VNI
                static_options:
                  values:
                    - VNI:VNI
                    - VLAN:VLAN
                    - VLAN:VNI
                format: null
                length: null
                pattern: null
                dynamic_options: null
            vlanBasedMacVrfAttributeFormats:
              id: vlanBasedMacVrfAttributeFormats
              name: vlanBasedMacVrfAttributeFormats
              label: VLAN Based MAC-VRF Attributes
              description: Set the default format for how VLAN based MAC-VRF attributes are generated.
              required: false
              type: INPUT_FIELD_TYPE_GROUP
              group_props:
                members:
                  values:
                    - vlanBasedMacVrfRouteDistinguisherFormat
                    - vlanBasedMacVrfRouteTargetFormat
            vlanBundleMacVrfRouteDistinguisherFormat:
              id: vlanBundleMacVrfRouteDistinguisherFormat
              name: macVrfRouteDistinguisherFormat
              label: MAC-VRF Route Distinguisher Format
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: Router-ID:First-VLAN
                static_options:
                  values:
                    - Router-ID:First-VLAN
                    - Router-ID:First-VNI
                    - Router-ID:Last-VLAN
                    - Router-ID:Last-VNI
                    - VTEP Source IP:First-VNI
                    - VTEP Source IP:Last-VLAN
                    - VTEP Source IP:First-VLAN
                    - VTEP Source IP:Last-VNI
                format: null
                length: null
                pattern: null
                dynamic_options: null
            vlanBundleMacVrfRouteTargetFormat:
              id: vlanBundleMacVrfRouteTargetFormat
              name: macVrfRouteTargetFormat
              label: MAC-VRF Route Target Format
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: First-VNI:Last-VNI
                static_options:
                  values:
                    - First-VLAN:First-VLAN
                    - First-VNI:First-VNI
                    - Last-VLAN:Last-VLAN
                    - Last-VNI:Last-VNI
                    - First-VLAN:Last-VLAN
                    - First-VNI:Last-VNI
                format: null
                length: null
                pattern: null
                dynamic_options: null
            vlanBundleMacVrfAttributeFormats:
              id: vlanBundleMacVrfAttributeFormats
              name: vlanBundleMacVrfAttributeFormats
              label: VLAN Bundle MAC-VRF Attributes
              description: Set the default format for how VLAN bundled MAC-VRF attributes are generated.
              required: false
              type: INPUT_FIELD_TYPE_GROUP
              group_props:
                members:
                  values:
                    - vlanBundleMacVrfRouteDistinguisherFormat
                    - vlanBundleMacVrfRouteTargetFormat
            evpnGwVtepPeerHostname:
              id: evpnGwVtepPeerHostname
              name: peerHostname
              label: Peer Hostname
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options: null
                format: null
                length: null
                pattern: null
                dynamic_options: null
            evpnGwVtepPeerIpAddress:
              id: evpnGwVtepPeerIpAddress
              name: peerIpAddress
              label: Peer IP Address
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options: null
                format: ip
                length: null
                pattern: null
                dynamic_options: null
            evpnGwVtepPeerBgpAsn:
              id: evpnGwVtepPeerBgpAsn
              name: peerBgpAsn
              label: Peer BGP ASN
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_INTEGER
              integer_props:
                default_value: null
                range: null
                static_options: null
                dynamic_options: null
            remoteEvpnGatewayVtepDetails:
              id: remoteEvpnGatewayVtepDetails
              name: remoteEvpnGatewayVtepDetails
              label: Remote EVPN Gateway VTEP Details
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_GROUP
              group_props:
                members:
                  values:
                    - evpnGwVtepPeerHostname
                    - evpnGwVtepPeerIpAddress
                    - evpnGwVtepPeerBgpAsn
            remoteEvpnGatewayVtepPeers:
              id: remoteEvpnGatewayVtepPeers
              name: remoteEvpnGatewayVtepPeers
              label: Remote EVPN Gateway VTEP Peers
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_COLLECTION
              collection_props:
                base_field_id: remoteEvpnGatewayVtepDetails
                key: ''
            remoteEvpnGatewayVtepEvpnL2Enable:
              id: remoteEvpnGatewayVtepEvpnL2Enable
              name: enable
              label: Enable
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_BOOLEAN
              boolean_props:
                default_value: false
            remoteEvpnGatewayVtepEvpnL2Details:
              id: remoteEvpnGatewayVtepEvpnL2Details
              name: evpnL2
              label: EVPN L2
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_GROUP
              group_props:
                members:
                  values:
                    - remoteEvpnGatewayVtepEvpnL2Enable
            remoteEvpnGatewayVtepEvpnL3Enable:
              id: remoteEvpnGatewayVtepEvpnL3Enable
              name: enable
              label: Enable
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_BOOLEAN
              boolean_props:
                default_value: false
            remoteEvpnGatewayVtepEvpnL3InterDomain:
              id: remoteEvpnGatewayVtepEvpnL3InterDomain
              name: interDomain
              label: Inter-Domain
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_BOOLEAN
              boolean_props:
                default_value: true
            remoteEvpnGatewayVtepEvpnL3Details:
              id: remoteEvpnGatewayVtepEvpnL3Details
              name: evpnL3
              label: EVPN L3
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_GROUP
              group_props:
                members:
                  values:
                    - remoteEvpnGatewayVtepEvpnL3Enable
                    - remoteEvpnGatewayVtepEvpnL3InterDomain
            remoteEvpnGatewayVtepsDetails:
              id: remoteEvpnGatewayVtepsDetails
              name: remoteEvpnGatewayVtepsDetails
              label: Remote EVPN Gateway VTEPs Details
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_GROUP
              group_props:
                members:
                  values:
                    - remoteEvpnGatewayVtepPeers
                    - remoteEvpnGatewayVtepEvpnL2Details
                    - remoteEvpnGatewayVtepEvpnL3Details
            evpnGatewayVteps:
              id: evpnGatewayVteps
              name: evpnGatewayVteps
              label: EVPN Gateway VTEPs
              description: Assign devices as EVPN-VXLAN gateways. This feature is only supported on select Jericho based platforms running EOS 4.26.1F or greater.
              required: false
              type: INPUT_FIELD_TYPE_RESOLVER
              resolver_props:
                base_field_id: remoteEvpnGatewayVtepsDetails
                display_mode: RESOLVER_FIELD_DISPLAY_MODE_SPARSE
                input_mode: RESOLVER_FIELD_INPUT_MODE_MULTI_DEVICE_TAG
                input_tag_label: null
                tag_filter_query: null
            evpnOverlayCoreBgpPeerGroupName:
              id: evpnOverlayCoreBgpPeerGroupName
              name: name
              label: Name
              description: Name of the peer group. If nothing is entered, the default name will be used.
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options: null
                format: null
                length: null
                pattern: null
                dynamic_options: null
            evpnOverlayCoreBgpPeerGroupPassword:
              id: evpnOverlayCoreBgpPeerGroupPassword
              name: password
              label: Password
              description: Enter the encrypted password for the peer group.  If nothing is entered, no password will be used in the BGP peering.
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options: null
                format: null
                length: null
                pattern: null
                dynamic_options: null
            evpnOverlayCorePeerGroupSettings:
              id: evpnOverlayCorePeerGroupSettings
              name: evpnOverlayCorePeerGroup
              label: EVPN Overlay Core Peer Group
              description: Settings for the BGP peer group used to establish peerings between EVPN gateway VTEPs
              required: false
              type: INPUT_FIELD_TYPE_GROUP
              group_props:
                members:
                  values:
                    - evpnOverlayCoreBgpPeerGroupName
                    - evpnOverlayCoreBgpPeerGroupPassword
            bgpPeerGroupSettings:
              id: bgpPeerGroupSettings
              name: bgpPeerGroupSettings
              label: BGP Peer Group Settings
              description: Customize BGP peer group properties.
              required: false
              type: INPUT_FIELD_TYPE_GROUP
              group_props:
                members:
                  values:
                    - evpnOverlayCorePeerGroupSettings
            advancedSettings:
              id: advancedSettings
              name: advancedSettings
              label: Advanced Settings
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_GROUP
              group_props:
                members:
                  values:
                    - bgpPeerGroupSettings
            root:
              id: root
              name: ''
              label: ''
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_GROUP
              group_props:
                members:
                  values:
                    - tenants
                    - vrfAttributeFormats
                    - vlanBasedMacVrfAttributeFormats
                    - vlanBundleMacVrfAttributeFormats
                    - evpnGatewayVteps
                    - advancedSettings
        layout:
          value: |
            {
              "vrfs":{
                "key":"vrfs",
                "type":"INPUT",
                "isPageLayout":true
              },
              "tenants":{
                "key":"tenants",
                "type":"INPUT",
                "isPageLayout":true
              },
              "vlans":{
                "key":"vlans",
                "type":"INPUT",
                "isPageLayout":true
              },
              "vlanBasedVlans":{
                "key":"vlanBasedVlans",
                "type":"INPUT",
                "order":[
                  "vlanId",
                  "vlanMemberSwitches",
                  "vlanBasedVlanName",
                  "vlanVxlanToggle",
                  "vlanL3OrL2",
                  "vlanVrf",
                  "vlanSVIIpAddresses",
                  "nodeVlanDetails",
                  "vlanDhcpServerDetails",
                  "vlanSviMtu",
                  "vlanSviArpDetails",
                  "eTreeDetails",
                  "etreeRootSwitches",
                  "vlanSviEosCliStatements",
                  "vlanEvpnMulticastDetails",
                  "vlanOverrideVariables"
                ]
              },
              "vrfGroup":{
                "key":"vrfGroup",
                "type":"INPUT",
                "order":[
                  "vrfName",
                  "vrfOverrideVNI",
                  "iBgpDetails",
                  "natSourceDetails",
                  "vrfL3InterfacesDevice",
                  "staticRoutesCollection",
                  "vrfRedistributeStaticRoutesToggle",
                  "externalBgpPeers",
                  "vrfRouterBgp",
                  "additionalRouteTargets",
                  "vrfEvpnMulticastDetails",
                  "vrfAssignDevicesResolver",
                  "vrfOverrideVariables"
                ]
              },
              "vlanL3OrL2":{
                "key":"vlanL3OrL2",
                "valueToLabelMap":{
                  "True":"Routed",
                  "False":"Bridged"
                },
                "type":"INPUT"
              },
              "vlanSviVirtualIpAddress":{
                "key":"vlanSviVirtualIpAddress",
                "dependency":{
                  "vlanL3OrL2":{
                    "value":[
                      true
                    ],
                    "mode":"SHOW"
                  },
                  "vlanVxlanToggle":{
                    "value":[
                      true
                    ],
                    "mode":"SHOW"
                  }
                },
                "dependencyType":"AND",
                "type":"INPUT"
              },
              "vlanSviSecondaryIpAddress":{
                "key":"vlanSviSecondaryIpAddress",
                "dependency":{
                  "vlanL3OrL2":{
                    "value":[
                      true
                    ],
                    "mode":"SHOW"
                  }
                },
                "type":"INPUT"
              },
              "tenantDefinition":{
                "key":"tenantDefinition",
                "type":"INPUT",
                "order":[
                  "tenantName",
                  "vrfs",
                  "macVrfVniBase",
                  "vlans",
                  "vlanAwareBundles",
                  "tenantEvpnMulticastDetails"
                ]
              },
              "iBgpDetails":{
                "key":"iBgpDetails",
                "type":"INPUT",
                "order":[
                  "iBgpVlanId",
                  "iBgpSubnet",
                  "iBgpSubnetMask"
                ]
              },
              "vlanDhcpServerVrf":{
                "key":"vlanDhcpServerVrf",
                "dependency":{
                  "vlanL3OrL2":{
                    "value":[
                      true
                    ],
                    "mode":"SHOW"
                  }
                },
                "type":"INPUT"
              },
              "vlanDhcpServers":{
                "key":"vlanDhcpServers",
                "dependency":{
                  "vlanL3OrL2":{
                    "value":[
                      true
                    ],
                    "mode":"SHOW"
                  }
                },
                "type":"INPUT"
              },
              "vlanAwareBundleGroup":{
                "key":"vlanAwareBundleGroup",
                "type":"INPUT",
                "order":[
                  "vlanAwareBundleName",
                  "vlanAwareBundleVlanRange",
                  "vlanAwareBundleOverrideVariables"
                ]
              },
              "vlanAwareBundles":{
                "key":"vlanAwareBundles",
                "type":"INPUT",
                "isPageLayout":true
              },
              "vlanMemberSwitches":{
                "key":"vlanMemberSwitches",
                "isPageLayout":true,
                "type":"INPUT",
                "showDefaultRow":false
              },
              "vlanVrf":{
                "key":"vlanVrf",
                "dependency":{
                  "vlanL3OrL2":{
                    "value":[
                      true
                    ],
                    "mode":"SHOW"
                  }
                },
                "type":"INPUT"
              },
              "vrfOverrideVariables":{
                "key":"vrfOverrideVariables",
                "type":"INPUT",
                "order":[
                  "vrfOverrideRouteDistinguisher",
                  "vrfOverrideRouteTarget"
                ]
              },
              "vlanMemberSwitchApply":{
                "key":"vlanMemberSwitchApply",
                "dependency":{
                  "vlanMemberSwitchApply":{
                    "value":[
                      false
                    ],
                    "mode":"SHOW"
                  }
                },
                "type":"INPUT"
              },
              "vlanSVIIpAddresses":{
                "key":"vlanSVIIpAddresses",
                "type":"INPUT",
                "order":[
                  "vlanSviVirtualIpAddress",
                  "vlanVirtualAddressConfigType",
                  "vlanPrimarySwitchSviIpAddress",
                  "vlanSecondarySwitchSviIpAddress"
                ]
              },
              "vlanVirtualAddressConfigType":{
                "key":"vlanVirtualAddressConfigType",
                "valueToLabelMap":{
                  "True":"ip address virtual",
                  "False":"ip virtual-router address"
                },
                "dependency":{
                  "vlanL3OrL2":{
                    "value":[
                      true
                    ],
                    "mode":"SHOW"
                  },
                  "vlanVxlanToggle":{
                    "value":[
                      true
                    ],
                    "mode":"SHOW"
                  }
                },
                "type":"INPUT",
                "dependencyType":"AND"
              },
              "natSourceDetails":{
                "key":"natSourceDetails",
                "type":"INPUT",
                "order":[
                  "sourceNatDataCenterResolver",
                  "sourceNatCampusResolver",
                  "natInterface"
                ]
              },
              "campusSite":{
                "key":"campusSite",
                "type":"INPUT",
                "isPageLayout":false
              },
              "vlanSviMtu":{
                "key":"vlanSviMtu",
                "dependency":{
                  "vlanL3OrL2":{
                    "value":[
                      true
                    ],
                    "mode":"SHOW"
                  }
                },
                "type":"INPUT"
              },
              "vlanSviArpAgingTimeout":{
                "key":"vlanSviArpAgingTimeout",
                "type":"INPUT",
                "dependency":{
                  "vlanL3OrL2":{
                    "value":[
                      true
                    ],
                    "mode":"SHOW"
                  }
                }
              },
              "vrfL3InterfacesDevice":{
                "key":"vrfL3InterfacesDevice",
                "type":"INPUT",
                "order":[
                  "vrfL3InterfacesCollection"
                ]
              },
              "vrfL3InterfacesCollection":{
                "key":"vrfL3InterfacesCollection",
                "type":"INPUT",
                "isPageLayout":true
              },
              "externalBgpPeers":{
                "key":"externalBgpPeers",
                "type":"INPUT",
                "isPageLayout":true
              },
              "externalBgpPeersDetails":{
                "key":"externalBgpPeersDetails",
                "type":"INPUT",
                "order":[
                  "externalBgpPeeringName",
                  "externalBgpPeersDevicesResolver",
                  "externalBgpPeersNeighborIpAddress",
                  "externalBgpPeersRemoteAs",
                  "externalBgpPeersDescription",
                  "externalBgpPeersPassword",
                  "externalBgpPeersSendCommunity",
                  "externalBgpPeersNextHopSelf",
                  "externalBgpPeersMaxRoutesGroup",
                  "externalBgpPeersUpdateSource",
                  "externalBgpPeersEbgpMultihop",
                  "externalBgpPeersWeight",
                  "externalBgpPeersNextHopGroup",
                  "externalBgpPeersRouteMapGroup",
                  "externalBgpPeersDefaultOriginate",
                  "externalBgpPeersLocalAs"
                ]
              },
              "staticRoutesCollection":{
                "key":"staticRoutesCollection",
                "type":"INPUT",
                "isPageLayout":true
              },
              "vlanSviCliStatement":{
                "key":"vlanSviCliStatement",
                "type":"INPUT",
                "dependency":{
                  "vlanL3OrL2":{
                    "value":[
                      true
                    ],
                    "mode":"SHOW"
                  }
                }
              },
              "vrfAssignDevicesGroup":{
                "key":"vrfAssignDevicesGroup",
                "type":"INPUT",
                "order":[
                  "vrfAssignHostname",
                  "vrfDeviceAssignmentSwitchFactsTagger"
                ]
              },
              "vlanMemberSwitch":{
                "key":"vlanMemberSwitch",
                "type":"INPUT",
                "order":[
                  "vlanMemberSwitchHostname",
                  "vlanDeviceAssignmentSwitchFactsTagger"
                ]
              },
              "additionalRouteTargetsApply":{
                "key":"additionalRouteTargetsApply",
                "dependency":{
                  "additionalRouteTargetsApply":{
                    "value":[
                      false
                    ],
                    "mode":"SHOW"
                  }
                },
                "type":"INPUT"
              },
              "externalBgpPeersApply":{
                "key":"externalBgpPeersApply",
                "dependency":{
                  "externalBgpPeersApply":{
                    "value":[
                      false
                    ],
                    "mode":"SHOW"
                  }
                },
                "type":"INPUT"
              },
              "staticRoutesApply":{
                "key":"staticRoutesApply",
                "dependency":{
                  "staticRoutesApply":{
                    "value":[
                      false
                    ],
                    "mode":"SHOW"
                  }
                },
                "type":"INPUT"
              },
              "vrfAssignApply":{
                "key":"vrfAssignApply",
                "type":"INPUT",
                "dependency":{
                  "vrfAssignApply":{
                    "value":[
                      false
                    ],
                    "mode":"SHOW"
                  }
                }
              },
              "staticRoutesNetworkServicesTagger":{
                "type":"TAGGER",
                "parentKey":"staticRoutesDevicesGroup",
                "key":"staticRoutesNetworkServicesTagger",
                "name":"Switch Facts",
                "assignmentType":"MULTIPLE",
                "prepopulate":true,
                "tagType":"DEVICE",
                "description":"Used to set switch properties necessary for VTEPs.",
                "columns":[
                  {
                    "tagLabel":"Vtep",
                    "suggestedValues":[
                      "True",
                      "False"
                    ]
                  },
                  {
                    "tagLabel":"NetworkServices",
                    "suggestedValues":[
                      "L2",
                      "L3"
                    ]
                  }
                ]
              },
              "vlanDeviceAssignmentSwitchFactsTagger":{
                "type":"TAGGER",
                "parentKey":"vlanMemberSwitch",
                "key":"vlanDeviceAssignmentSwitchFactsTagger",
                "name":"Switch Facts",
                "assignmentType":"MULTIPLE",
                "prepopulate":true,
                "tagFilterQuery":"Vtep:True ",
                "tagType":"DEVICE",
                "description":"Used to set switch properties necessary for VTEPs.",
                "columns":[
                  {
                    "tagLabel":"Vtep",
                    "suggestedValues":[
                      "True",
                      "False"
                    ]
                  },
                  {
                    "tagLabel":"NetworkServices",
                    "suggestedValues":[
                      "L2",
                      "L3"
                    ]
                  },
                  {
                    "tagLabel":"router_bgp.as",
                    "suggestedValues":[
                    ]
                  },
                  {
                    "tagLabel":"router_bgp.router_id",
                    "suggestedValues":[
                    ]
                  }
                ]
              },
              "externalBgpPeersSwitchFactsTagger":{
                "type":"TAGGER",
                "parentKey":"externalBgpPeersDevicesGroup",
                "key":"externalBgpPeersSwitchFactsTagger",
                "name":"Switch Facts",
                "assignmentType":"MULTIPLE",
                "prepopulate":true,
                "tagType":"DEVICE",
                "description":"Used to set switch properties necessary for VTEPs.",
                "columns":[
                  {
                    "tagLabel":"Vtep",
                    "suggestedValues":[
                      "True",
                      "False"
                    ]
                  },
                  {
                    "tagLabel":"NetworkServices",
                    "suggestedValues":[
                      "L2",
                      "L3"
                    ]
                  },
                  {
                    "tagLabel":"router_bgp.as",
                    "suggestedValues":[
                    ]
                  },
                  {
                    "tagLabel":"router_bgp.router_id",
                    "suggestedValues":[
                    ]
                  }
                ]
              },
              "additionalRouteTargetsSwitchFactsTagger":{
                "type":"TAGGER",
                "parentKey":"additionalRouteTargetsDevicesGroup",
                "key":"additionalRouteTargetsSwitchFactsTagger",
                "name":"Switch Facts",
                "assignmentType":"MULTIPLE",
                "prepopulate":false,
                "tagType":"DEVICE",
                "description":"Used to set switch properties necessary for VTEPs.",
                "columns":[
                  {
                    "tagLabel":"Vtep",
                    "suggestedValues":[
                      "True",
                      "False"
                    ]
                  },
                  {
                    "tagLabel":"NetworkServices",
                    "suggestedValues":[
                      "L2",
                      "L3"
                    ]
                  },
                  {
                    "tagLabel":"router_bgp.as",
                    "suggestedValues":[
                    ]
                  },
                  {
                    "tagLabel":"router_bgp.router_id",
                    "suggestedValues":[
                    ]
                  }
                ]
              },
              "vrfDeviceAssignmentSwitchFactsTagger":{
                "type":"TAGGER",
                "parentKey":"vrfAssignDevicesGroup",
                "key":"vrfDeviceAssignmentSwitchFactsTagger",
                "name":"Switch Facts",
                "assignmentType":"MULTIPLE",
                "prepopulate":false,
                "tagType":"DEVICE",
                "description":"Used to set switch properties necessary for VTEPs.",
                "columns":[
                  {
                    "tagLabel":"Vtep",
                    "suggestedValues":[
                      "True",
                      "False"
                    ]
                  },
                  {
                    "tagLabel":"NetworkServices",
                    "suggestedValues":[
                      "L2",
                      "L3"
                    ]
                  },
                  {
                    "tagLabel":"router_bgp.as",
                    "suggestedValues":[
                    ]
                  },
                  {
                    "tagLabel":"router_bgp.router_id",
                    "suggestedValues":[
                    ]
                  }
                ]
              },
              "nodeVirtualSviIpAddress":{
                "key":"nodeVirtualSviIpAddress",
                "dependency":{
                  "vlanL3OrL2":{
                    "value":[
                      true
                    ],
                    "mode":"SHOW"
                  },
                  "vlanVirtualAddressConfigType":{
                    "value":[
                      false
                    ],
                    "mode":"SHOW"
                  },
                  "vlanVxlanToggle":{
                    "value":[
                      false
                    ],
                    "mode":"SHOW"
                  }
                },
                "dependencyType":"AND",
                "type":"INPUT"
              },
              "nodeSviIpAddress":{
                "key":"nodeSviIpAddress",
                "dependency":{
                  "vlanL3OrL2":{
                    "value":[
                      true
                    ],
                    "mode":"SHOW"
                  },
                  "vlanVirtualAddressConfigType":{
                    "value":[
                      false
                    ],
                    "mode":"SHOW"
                  }
                },
                "dependencyType":"AND",
                "type":"INPUT"
              },
              "nodeVlanDetails":{
                "key":"nodeVlanDetails",
                "type":"INPUT",
                "fieldOverrides":{
                  "label":"Device",
                  "description":"Add switches to set SVI IP addresses for.",
                  "addButtonLabel":"Device"
                }
              },
              "externalBgpPeersDefaultOriginate":{
                "key":"externalBgpPeersDefaultOriginate",
                "type":"INPUT",
                "order":[
                  "ebgpPeerDefaultOriginateEnable",
                  "externalBgpPeersDefaultOriginateAlways"
                ]
              },
              "externalBgpPeersDefaultOriginateAlways":{
                "key":"externalBgpPeersDefaultOriginateAlways",
                "type":"INPUT",
                "dependency":{
                  "ebgpPeerDefaultOriginateEnable":{
                    "value":[
                      true
                    ],
                    "mode":"SHOW"
                  }
                },
                "dependencyType":"AND"
              },
              "etreeRootSwitches":{
                "key":"etreeRootSwitches",
                "type":"INPUT",
                "isPageLayout":false,
                "showDefaultRow":false
              },
              "etreeEnable":{
                "key":"etreeEnable",
                "type":"INPUT",
                "dependencyType":"AND",
                "dependency":{
                  "vlanL3OrL2":{
                    "value":[
                      false
                    ],
                    "mode":"SHOW"
                  }
                }
              },
              "etreeRole":{
                "key":"etreeRole",
                "dependency":{
                  "vlanL3OrL2":{
                    "value":[
                      false
                    ],
                    "mode":"SHOW"
                  },
                  "etreeEnable":{
                    "value":[
                      true
                    ],
                    "mode":"SHOW"
                  }
                },
                "dependencyType":"AND",
                "type":"INPUT"
              },
              "leafExportRouteTargetOffset":{
                "key":"leafExportRouteTargetOffset",
                "dependency":{
                  "vlanL3OrL2":{
                    "value":[
                      false
                    ],
                    "mode":"SHOW"
                  },
                  "etreeEnable":{
                    "value":[
                      true
                    ],
                    "mode":"SHOW"
                  }
                },
                "dependencyType":"AND",
                "type":"INPUT"
              },
              "evpnGatewayVteps":{
                "key":"evpnGatewayVteps",
                "type":"INPUT",
                "showDefaultRow":false
              },
              "remoteEvpnGatewayVtepEvpnL3InterDomain":{
                "key":"remoteEvpnGatewayVtepEvpnL3InterDomain",
                "type":"INPUT",
                "dependencyType":"AND",
                "dependency":{
                  "remoteEvpnGatewayVtepEvpnL3Enable":{
                    "value":[
                      true
                    ],
                    "mode":"SHOW"
                  }
                }
              },
              "vlanPrimarySwitchSviIpAddress":{
                "key":"vlanPrimarySwitchSviIpAddress",
                "dependencyType":"AND",
                "type":"INPUT",
                "dependency":{
                  "vlanL3OrL2":{
                    "value":[
                      true
                    ],
                    "mode":"SHOW"
                  },
                  "vlanVxlanToggle":{
                    "value":[
                      true
                    ],
                    "mode":"SHOW"
                  },
                  "vlanVirtualAddressConfigType":{
                    "value":[
                      false
                    ],
                    "mode":"SHOW"
                  }
                }
              },
              "vlanSecondarySwitchSviIpAddress":{
                "key":"vlanSecondarySwitchSviIpAddress",
                "type":"INPUT",
                "dependencyType":"AND",
                "dependency":{
                  "vlanL3OrL2":{
                    "value":[
                      true
                    ],
                    "mode":"SHOW"
                  },
                  "vlanVxlanToggle":{
                    "value":[
                      true
                    ],
                    "mode":"SHOW"
                  },
                  "vlanVirtualAddressConfigType":{
                    "value":[
                      false
                    ],
                    "mode":"SHOW"
                  }
                }
              },
              "tenantEvpnMulticastDetails":{
                "key":"tenantEvpnMulticastDetails",
                "type":"INPUT",
                "order":[
                  "tenantL2EvpnMulticastDetails",
                  "tenantL3EvpnMulticastDetails"
                ]
              },
              "vlanL3EvpnMulticastEnabled":{
                "key":"vlanL3EvpnMulticastEnabled",
                "dependency":{
                  "vlanL3OrL2":{
                    "value":[
                      true
                    ],
                    "mode":"SHOW"
                  },
                  "tenantL3EvpnMulticastEnabled":{
                    "value":[
                      "Yes"
                    ],
                    "mode":"SHOW"
                  },
                  "vlanVxlanToggle":{
                    "value":[
                      true
                    ],
                    "mode":"SHOW"
                  }
                },
                "dependencyType":"AND",
                "type":"INPUT"
              },
              "vlanL2EvpnMulticastEnabled":{
                "key":"vlanL2EvpnMulticastEnabled",
                "dependency":{
                  "vlanL3OrL2":{
                    "value":[
                      false
                    ],
                    "mode":"SHOW"
                  },
                  "tenantL2EvpnMulticastEnabled":{
                    "value":[
                      "Yes"
                    ],
                    "mode":"SHOW"
                  },
                  "vlanVxlanToggle":{
                    "value":[
                      true
                    ],
                    "mode":"SHOW"
                  }
                },
                "dependencyType":"AND",
                "type":"INPUT"
              },
              "vrfL3EvpnMulticastEnabled":{
                "key":"vrfL3EvpnMulticastEnabled",
                "type":"INPUT",
                "dependencyType":"AND",
                "dependency":{
                  "tenantL3EvpnMulticastEnabled":{
                    "value":[
                      "Yes"
                    ],
                    "mode":"SHOW"
                  }
                }
              },
              "tenantL3EvpnMulticastDetails":{
                "key":"tenantL3EvpnMulticastDetails",
                "type":"INPUT",
                "order":[
                  "tenantL3EvpnMulticastEnabled",
                  "tenantL3EvpnMulticast",
                  "tenantEvpnPegResolver",
                  "tenantPimRpAddressesCollection"
                ]
              },
              "vrfPimRpsGroupName":{
                "key":"vrfPimRpsGroupName",
                "dependency":{
                  "tenantL3EvpnMulticastEnabled":{
                    "value":[
                      "Yes"
                    ],
                    "mode":"SHOW"
                  },
                  "vrfL3EvpnMulticastEnabled":{
                    "value":[
                      "No"
                    ],
                    "mode":"HIDE"
                  }
                },
                "dependencyType":"AND",
                "type":"INPUT"
              },
              "vrfPimRpsIpAddressesIpAddress":{
                "key":"vrfPimRpsIpAddressesIpAddress",
                "dependency":{
                  "tenantL3EvpnMulticastEnabled":{
                    "value":[
                      "Yes"
                    ],
                    "mode":"SHOW"
                  },
                  "vrfL3EvpnMulticastEnabled":{
                    "value":[
                      "No"
                    ],
                    "mode":"HIDE"
                  }
                },
                "dependencyType":"AND",
                "type":"INPUT"
              },
              "vrfPimRpsGroupAddressesGroupAddress":{
                "key":"vrfPimRpsGroupAddressesGroupAddress",
                "dependency":{
                  "tenantL3EvpnMulticastEnabled":{
                    "value":[
                      "Yes"
                    ],
                    "mode":"SHOW"
                  },
                  "vrfL3EvpnMulticastEnabled":{
                    "value":[
                      "No"
                    ],
                    "mode":"HIDE"
                  }
                },
                "dependencyType":"AND",
                "type":"INPUT"
              },
              "vrfEvpnMulticastDetails":{
                "key":"vrfEvpnMulticastDetails",
                "type":"INPUT",
                "order":[
                  "vrfL3EvpnMulticastEnabled",
                  "vrfEvpnPegResolver",
                  "vrfPimRpAddressesCollection"
                ]
              },
              "tenantL2EvpnMulticastGroupIpv4Pool":{
                "key":"tenantL2EvpnMulticastGroupIpv4Pool",
                "type":"INPUT",
                "dependencyType":"AND",
                "dependency":{
                  "tenantL2EvpnMulticastEnabled":{
                    "value":[
                      "Yes"
                    ],
                    "mode":"SHOW"
                  }
                }
              },
              "tenantL2EvpnMulticastGroupIpv4PoolOffset":{
                "key":"tenantL2EvpnMulticastGroupIpv4PoolOffset",
                "type":"INPUT",
                "dependencyType":"AND",
                "dependency":{
                  "tenantL2EvpnMulticastEnabled":{
                    "value":[
                      "Yes"
                    ],
                    "mode":"SHOW"
                  }
                }
              },
              "tenantL3EvpnMulticastGroupIpv4Pool":{
                "key":"tenantL3EvpnMulticastGroupIpv4Pool",
                "type":"INPUT",
                "dependencyType":"AND",
                "dependency":{
                  "tenantL3EvpnMulticastEnabled":{
                    "value":[
                      "Yes"
                    ],
                    "mode":"SHOW"
                  }
                }
              },
              "tenantL3EvpnMulticastGroupIpv4PoolOffset":{
                "key":"tenantL3EvpnMulticastGroupIpv4PoolOffset",
                "type":"INPUT",
                "dependencyType":"AND",
                "dependency":{
                  "tenantL3EvpnMulticastEnabled":{
                    "value":[
                      "Yes"
                    ],
                    "mode":"SHOW"
                  }
                }
              },
              "tenantEvpnPegTransitMode":{
                "key":"tenantEvpnPegTransitMode",
                "type":"INPUT",
                "dependencyType":"AND",
                "dependency":{
                  "tenantL3EvpnMulticastEnabled":{
                    "value":[
                      "Yes"
                    ],
                    "mode":"SHOW"
                  }
                }
              },
              "tenantPimRpsGroupName":{
                "key":"tenantPimRpsGroupName",
                "type":"INPUT",
                "dependencyType":"AND",
                "dependency":{
                  "tenantL3EvpnMulticastEnabled":{
                    "value":[
                      "Yes"
                    ],
                    "mode":"SHOW"
                  }
                }
              },
              "tenantPimRpsIpAddressesIpAddress":{
                "key":"tenantPimRpsIpAddressesIpAddress",
                "type":"INPUT",
                "dependencyType":"AND",
                "dependency":{
                  "tenantL3EvpnMulticastEnabled":{
                    "value":[
                      "Yes"
                    ],
                    "mode":"SHOW"
                  }
                }
              },
              "tenantPimRpsGroupAddressesGroupAddress":{
                "key":"tenantPimRpsGroupAddressesGroupAddress",
                "type":"INPUT",
                "dependencyType":"AND",
                "dependency":{
                  "tenantL3EvpnMulticastEnabled":{
                    "value":[
                      "Yes"
                    ],
                    "mode":"SHOW"
                  }
                }
              },
              "vrfEvpnPegTransitMode":{
                "key":"vrfEvpnPegTransitMode",
                "dependency":{
                  "tenantL3EvpnMulticastEnabled":{
                    "value":[
                      "Yes"
                    ],
                    "mode":"SHOW"
                  },
                  "vrfL3EvpnMulticastEnabled":{
                    "value":[
                      "No"
                    ],
                    "mode":"HIDE"
                  }
                },
                "dependencyType":"AND",
                "type":"INPUT"
              }
            }
